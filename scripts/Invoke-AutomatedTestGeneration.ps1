#Requires -Version 7.0

<#
.SYNOPSIS
    Automated test generation and validation script for OpenTofu Lab Automation core app
    
.DESCRIPTION
    This script provides continuous test generation and validation for the core app:
    - Monitors core app scripts for changes
    - Automatically generates Pester tests for new functions/scripts
    - Validates existing test coverage
    - Integrates with PatchManager workflow
    - Enforces TDD practices
    
.PARAMETER Mode
    Operation mode: Monitor, Generate, Validate, or All
    
.PARAMETER WatchPath
    Path to monitor for changes (defaults to core app directory)
    
.PARAMETER OutputPath
    Path where generated tests should be saved
    
.PARAMETER PatchManagerMode
    Whether to use PatchManager for all changes
    
.EXAMPLE
    ./Invoke-AutomatedTestGeneration.ps1 -Mode Monitor
    Continuously monitors for changes and generates tests
    
.EXAMPLE
    ./Invoke-AutomatedTestGeneration.ps1 -Mode Generate -WatchPath "./pwsh/core_app"
    Generates tests for all scripts in core app directory
#>

[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter()]
    [ValidateSet('Monitor', 'Generate', 'Validate', 'All')]
    [string]$Mode = 'All',
    
    [Parameter()]
    [string]$WatchPath = "$env:PROJECT_ROOT/pwsh/core_app",
    
    [Parameter()]
    [string]$OutputPath = "$env:PROJECT_ROOT/tests",
    
    [Parameter()]
    [switch]$PatchManagerMode = $true,
    
    [Parameter()]
    [int]$MonitorIntervalSeconds = 30
)

# Import required modules
Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force

function Write-CustomLog {
    param(
        [string]$Message,
        [ValidateSet('INFO', 'WARN', 'ERROR', 'SUCCESS')]
        [string]$Level = 'INFO'
    )
    
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $prefix = switch ($Level) {
        'INFO' { "üí°" }
        'WARN' { "‚ö†Ô∏è" }
        'ERROR' { "‚ùå" }
        'SUCCESS' { "‚úÖ" }
    }
    
    Write-Host "[$timestamp] $prefix $Message" -ForegroundColor $(
        switch ($Level) {
            'INFO' { 'Cyan' }
            'WARN' { 'Yellow' }
            'ERROR' { 'Red' }
            'SUCCESS' { 'Green' }
        }
    )
}

function Get-ScriptFunctions {
    param([string]$ScriptPath)
    
    try {
        $ast = [System.Management.Automation.Language.Parser]::ParseFile($ScriptPath, [ref]$null, [ref]$null)
        $functions = $ast.FindAll({ $args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true)
        
        return $functions | ForEach-Object {
            @{
                Name = $_.Name
                Parameters = $_.Parameters | ForEach-Object { $_.Name.VariablePath.UserPath }
                StartLine = $_.Extent.StartLineNumber
                EndLine = $_.Extent.EndLineNumber
            }
        }
    } catch {
        Write-CustomLog "Failed to parse script $ScriptPath`: $_" -Level ERROR
        return @()
    }
}

function New-PesterTestTemplate {
    param(
        [string]$ScriptName,
        [array]$Functions,
        [string]$ScriptPath
    )
    
    $template = @"
#Requires -Version 7.0
#Requires -Module Pester

<#
.SYNOPSIS
    Automated Pester tests for $ScriptName
    
.DESCRIPTION
    Generated tests for core app script validation and functionality
    Auto-generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
#>

using module PatchManager

BeforeAll {
    Import-Module "`$env:PROJECT_ROOT/pwsh/modules/PatchManager/" -Force
    . "`$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    
    `$script:ScriptPath = "$ScriptPath"
    `$script:ScriptName = "$ScriptName"
}

Describe "$ScriptName Tests" -Tag @('Critical', 'CoreApp', 'AutoGenerated') {
    
    Context "Script Structure Validation" {
        
        It "should have valid PowerShell syntax" {
            `$errors = `$null
            [System.Management.Automation.Language.Parser]::ParseFile(`$script:ScriptPath, [ref]`$null, [ref]`$errors) | Out-Null
            `$errorCount = if (`$errors) { `$errors.Count } else { 0 }
            `$errorCount | Should -Be 0
        }
        
        It "should follow PowerShell 7.0+ standards" {
            `$content = Get-Content `$script:ScriptPath -Raw
            `$content | Should -Match '#Requires -Version 7\.0'
        }
        
        It "should use cross-platform paths" {
            `$content = Get-Content `$script:ScriptPath -Raw
            `$content | Should -Not -Match '\\\\|C:\\'
        }
        
        It "should implement proper error handling" {
            `$content = Get-Content `$script:ScriptPath -Raw
            if (`$content -match 'Install-|Enable-|Configure-') {
                `$content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch'
            }
        }
    }
"@

    if ($Functions.Count -gt 0) {
        $template += @"

    Context "Function Validation" {
"@
        
        foreach ($function in $Functions) {
            $template += @"

        It "should define $($function.Name) function" {
            `$content = Get-Content `$script:ScriptPath -Raw
            `$content | Should -Match "function\s+$($function.Name)"
        }
        
        It "should have proper parameter validation for $($function.Name)" {
            `$content = Get-Content `$script:ScriptPath -Raw
            if (`$content -match "function\s+$($function.Name)") {
                `$content | Should -Match '\[CmdletBinding\(\)\]|\[Parameter\('
            }
        }
"@
            
            if ($function.Parameters.Count -gt 0) {
                foreach ($param in $function.Parameters) {
                    $template += @"

        It "should accept $param parameter in $($function.Name)" {
            `$content = Get-Content `$script:ScriptPath -Raw
            `$content | Should -Match "\`$$param"
        }
"@
                }
            }
        }
        
        $template += @"

    }
"@
    }
    
    $template += @"

    Context "Execution Validation" {
        
        It "should execute without syntax errors" {
            if (Test-Path `$script:ScriptPath) {
                { & `$script:ScriptPath -WhatIf } | Should -Not -Throw
            }
        }
        
        It "should support WhatIf parameter" {
            `$content = Get-Content `$script:ScriptPath -Raw
            `$content | Should -Match 'SupportsShouldProcess|WhatIf'
        }
        
        It "should use standardized logging" {
            `$content = Get-Content `$script:ScriptPath -Raw
            if (`$content -match 'Write-') {
                `$content | Should -Match 'Write-CustomLog'
            }
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            { Import-Module "`$env:PROJECT_ROOT/pwsh/modules/PatchManager/" -Force } | Should -Not -Throw
        }
        
        It "should support change tracking" {
            Get-Command New-PatchOperation -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty
        }
    }
}

AfterAll {
    Write-CustomLog "Tests completed for `$script:ScriptName" -Level SUCCESS
}
"@
    
    return $template
}

function Invoke-TestGeneration {
    param([string]$TargetPath)
    
    Write-CustomLog "Generating tests for scripts in: $TargetPath" -Level INFO
    
    $scripts = Get-ChildItem -Path $TargetPath -Filter "*.ps1" -Recurse | Where-Object { 
        $_.Name -notmatch '\.Tests\.ps1$' -and $_.Name -ne 'Invoke-AutomatedTestGeneration.ps1'
    }
    
    $generatedCount = 0
    
    foreach ($script in $scripts) {
        $testFileName = ($script.BaseName + '.Tests.ps1')
        $testFilePath = Join-Path $OutputPath $testFileName
        
        # Skip if test already exists and is newer than the script
        if (Test-Path $testFilePath) {
            $testFileAge = (Get-Item $testFilePath).LastWriteTime
            $scriptAge = $script.LastWriteTime
            
            if ($testFileAge -gt $scriptAge) {
                Write-CustomLog "Test file $testFileName is up to date" -Level INFO
                continue
            }
        }
        
        Write-CustomLog "Analyzing script: $($script.Name)" -Level INFO
        $functions = Get-ScriptFunctions -ScriptPath $script.FullName
        
        if ($functions.Count -gt 0) {
            Write-CustomLog "Found $($functions.Count) functions in $($script.Name)" -Level INFO
        }
        
        $testContent = New-PesterTestTemplate -ScriptName $script.Name -Functions $functions -ScriptPath $script.FullName
        
        if ($PatchManagerMode -and $PSCmdlet.ShouldProcess($testFilePath, "Create/Update test file")) {
            # Use PatchManager for the change
            $patchOp = New-PatchOperation -Type 'Create' -TargetPath $testFilePath -Description "Auto-generated tests for $($script.Name)"
            
            try {
                Set-Content -Path $testFilePath -Value $testContent -Encoding UTF8
                Submit-PatchForReview -PatchOperation $patchOp -AutoApprove:$true
                Write-CustomLog "Generated test file: $testFileName (via PatchManager)" -Level SUCCESS
                $generatedCount++
            } catch {
                Write-CustomLog "Failed to create test file $testFileName`: $_" -Level ERROR
            }
        } elseif (-not $PatchManagerMode -and $PSCmdlet.ShouldProcess($testFilePath, "Create/Update test file")) {
            try {
                Set-Content -Path $testFilePath -Value $testContent -Encoding UTF8
                Write-CustomLog "Generated test file: $testFileName" -Level SUCCESS
                $generatedCount++
            } catch {
                Write-CustomLog "Failed to create test file $testFileName`: $_" -Level ERROR
            }
        }
    }
    
    Write-CustomLog "Generated $generatedCount test files" -Level SUCCESS
}

function Invoke-TestValidation {
    Write-CustomLog "Validating existing test coverage..." -Level INFO
    
    $coreScripts = Get-ChildItem -Path $WatchPath -Filter "*.ps1" -Recurse | Where-Object { 
        $_.Name -notmatch '\.Tests\.ps1$' 
    }
    
    $testFiles = Get-ChildItem -Path $OutputPath -Filter "*.Tests.ps1"
    $coverage = @{}
    
    foreach ($script in $coreScripts) {
        $expectedTestFile = ($script.BaseName + '.Tests.ps1')
        $testExists = $testFiles | Where-Object { $_.Name -eq $expectedTestFile }
        
        $coverage[$script.Name] = @{
            HasTest = [bool]$testExists
            TestFile = if ($testExists) { $testExists.FullName } else { $null }
            LastModified = $script.LastWriteTime
        }
    }
    
    $totalScripts = $coverage.Count
    $testedScripts = ($coverage.Values | Where-Object { $_.HasTest }).Count
    $coveragePercentage = if ($totalScripts -gt 0) { [math]::Round(($testedScripts / $totalScripts) * 100, 2) } else { 0 }
    
    Write-CustomLog "Test Coverage Report:" -Level INFO
    Write-CustomLog "  Total Scripts: $totalScripts" -Level INFO
    Write-CustomLog "  Scripts with Tests: $testedScripts" -Level INFO
    Write-CustomLog "  Coverage Percentage: $coveragePercentage%" -Level INFO
    
    # Generate coverage report
    $report = @{
        Timestamp = Get-Date
        TotalScripts = $totalScripts
        TestedScripts = $testedScripts
        CoveragePercentage = $coveragePercentage
        Details = $coverage
    }
    
    $reportPath = Join-Path $OutputPath "TestCoverage-Report.json"
    $report | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
    Write-CustomLog "Coverage report saved to: $reportPath" -Level SUCCESS
    
    # Recommend actions for low coverage
    if ($coveragePercentage -lt 80) {
        Write-CustomLog "Test coverage is below 80%. Consider running test generation." -Level WARN
    }
    
    return $report
}

function Start-TestMonitoring {
    Write-CustomLog "Starting test monitoring for: $WatchPath" -Level INFO
    Write-CustomLog "Monitor interval: $MonitorIntervalSeconds seconds" -Level INFO
    Write-CustomLog "Press Ctrl+C to stop monitoring" -Level INFO
    
    $lastCheck = Get-Date
    
    try {
        while ($true) {
            Start-Sleep -Seconds $MonitorIntervalSeconds
            
            # Check for modified files since last check
            $modifiedFiles = Get-ChildItem -Path $WatchPath -Filter "*.ps1" -Recurse | 
                Where-Object { $_.LastWriteTime -gt $lastCheck -and $_.Name -notmatch '\.Tests\.ps1$' }
            
            if ($modifiedFiles.Count -gt 0) {
                Write-CustomLog "Detected $($modifiedFiles.Count) modified script(s)" -Level INFO
                
                foreach ($file in $modifiedFiles) {
                    Write-CustomLog "Modified: $($file.Name)" -Level INFO
                }
                
                # Regenerate tests for modified files
                Invoke-TestGeneration -TargetPath $WatchPath
                
                # Run validation
                Invoke-TestValidation
            }
            
            $lastCheck = Get-Date
        }
    } catch [System.Management.Automation.PipelineStoppedException] {
        Write-CustomLog "Monitoring stopped by user" -Level INFO
    } catch {
        Write-CustomLog "Monitoring error: $_" -Level ERROR
    }
}

function Invoke-PesterTestExecution {
    Write-CustomLog "Executing generated Pester tests..." -Level INFO
    
    try {
        $config = New-PesterConfiguration
        $config.Run.Path = $OutputPath
        $config.Filter.Tag = @('AutoGenerated', 'CoreApp')
        $config.Output.Verbosity = 'Detailed'
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputPath = "$env:PROJECT_ROOT/coverage/AutoGenerated-TestResults.xml"
        $config.CodeCoverage.Enabled = $true
        $config.CodeCoverage.Path = $WatchPath
        $config.CodeCoverage.OutputPath = "$env:PROJECT_ROOT/coverage/AutoGenerated-Coverage.xml"
        
        $result = Invoke-Pester -Configuration $config
        
        Write-CustomLog "Test execution completed:" -Level INFO
        Write-CustomLog "  Total: $($result.TotalCount)" -Level INFO  
        Write-CustomLog "  Passed: $($result.PassedCount)" -Level SUCCESS
        Write-CustomLog "  Failed: $($result.FailedCount)" -Level $(if ($result.FailedCount -gt 0) { 'ERROR' } else { 'INFO' })
        Write-CustomLog "  Skipped: $($result.SkippedCount)" -Level INFO
        
        return $result
    } catch {
        Write-CustomLog "Test execution failed: $_" -Level ERROR
        return $null
    }
}

# Main execution logic
Write-CustomLog "Starting Automated Test Generation for OpenTofu Lab Automation Core App" -Level INFO
Write-CustomLog "Mode: $Mode" -Level INFO
Write-CustomLog "Watch Path: $WatchPath" -Level INFO
Write-CustomLog "Output Path: $OutputPath" -Level INFO
Write-CustomLog "PatchManager Mode: $PatchManagerMode" -Level INFO

# Ensure paths exist
if (-not (Test-Path $WatchPath)) {
    Write-CustomLog "Watch path does not exist: $WatchPath" -Level ERROR
    exit 1
}

if (-not (Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
    Write-CustomLog "Created output directory: $OutputPath" -Level INFO
}

# Execute based on mode
switch ($Mode) {
    'Generate' {
        Invoke-TestGeneration -TargetPath $WatchPath
    }
    'Validate' {
        Invoke-TestValidation
    }
    'Monitor' {
        Start-TestMonitoring
    }
    'All' {
        Write-CustomLog "Running comprehensive test automation..." -Level INFO
        
        # Generate tests
        Invoke-TestGeneration -TargetPath $WatchPath
        
        # Validate coverage
        $coverage = Invoke-TestValidation
        
        # Execute tests
        $testResults = Invoke-PesterTestExecution
        
        # Summary report
        Write-CustomLog "=== AUTOMATION SUMMARY ===" -Level INFO
        Write-CustomLog "Test Coverage: $($coverage.CoveragePercentage)%" -Level INFO
        if ($testResults) {
            Write-CustomLog "Test Results: $($testResults.PassedCount)/$($testResults.TotalCount) passed" -Level INFO
        }
        Write-CustomLog "Automation completed successfully" -Level SUCCESS
    }
}

Write-CustomLog "Automated Test Generation completed" -Level SUCCESS





