#Requires -Version 7.0
<#
.SYNOPSIS
Enhanced pre-commit validation integrated into PatchManager with anti-recursive protection

.DESCRIPTION
Provides comprehensive pre-commit validation with:
- Anti-recursive branching protection
- Automated error detection and fixing
- GitHub issue creation for unresolved errors
- PatchManager workflow enforcement
- Technical error reporting without flowery language

.PARAMETER StagedFiles
Array of staged files to validate (auto-detected if not provided)

.# ValidationOnly parameter removed
Automatically fix simple syntax errors when possible

.PARAMETER CreateIssue
Create GitHub issue for unresolved errors

.PARAMETER BlockCommit
Block commit if critical errors are found

.EXAMPLE
Invoke-EnhancedPreCommitValidation  -CreateIssue -BlockCommit

.NOTES
- Integrated with PatchManager anti-recursive logic
- No emojis - technical output only
- Creates issues for problems that can't be auto-resolved
#>

function Invoke-EnhancedPreCommitValidation {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $false)]
        [string[]]$StagedFiles,
        
        [Parameter(Mandatory = $false)]
        
        [Parameter(Mandatory = $false)]
        [switch]$CreateIssue,
        
        [Parameter(Mandatory = $false)]
        [switch]$BlockCommit = $true
    )      try {
        # Import required modules with proper error handling
        $projectRoot = if ($env:PROJECT_ROOT) { $env:PROJECT_ROOT } else { (Get-Location).Path }
        $importManagerPath = Join-Path $projectRoot "pwsh/modules/ImportManager"
        
        if (Test-Path $importManagerPath) {
            Import-Module $importManagerPath -Force -ErrorAction SilentlyContinue
            $importResults = Import-AllCoreModules -Silent
        } else {
            # Create fallback Write-CustomLog if not available
            if (-not (Get-Command Write-CustomLog -ErrorAction SilentlyContinue)) {
                function Write-CustomLog {
                    param($Level, $Message)
                    $color = switch ($Level) {
                        "ERROR" { "Red" }
                        "WARN" { "Yellow" }
                        "SUCCESS" { "Green" }
                        "INFO" { "Cyan" }
                        default { "White" }
                    }
                    Write-Host "[$Level] $Message" -ForegroundColor $color
                }
            }
        }
        
        Write-CustomLog -Level INFO -Message "Starting enhanced pre-commit validation"
        
        # Step 1: Anti-recursive branch check
        $currentBranch = git rev-parse --abbrev-ref HEAD 2>$null
        if (-not $currentBranch) { $currentBranch = "unknown" }
        
        Write-CustomLog -Level INFO -Message "Current branch: $currentBranch"
        
        # Check if direct commits to main are blocked
        if ($currentBranch -eq 'main' -or $currentBranch -eq 'master') {
            Write-CustomLog -Level ERROR -Message "Direct commits to main/master branch blocked"
            Write-CustomLog -Level INFO -Message "Use PatchManager: Get-IntelligentBranchStrategy -PatchDescription 'description'"
            
            if ($CreateIssue) {
                $issueResult = New-GitHubIssue -Title "Direct commit to main branch blocked" -Body @"
## Branch Policy Violation

**Branch:** $currentBranch
**Issue:** Direct commit to protected branch attempted
**Resolution:** Use PatchManager workflow with feature branch

### Required Actions:
1. Create feature branch using Get-IntelligentBranchStrategy
2. Apply changes in feature branch  
3. Create pull request for review
4. Merge after approval

**Auto-generated by PatchManager pre-commit validation**
"@ -Labels @("policy-violation", "workflow")
                
                if ($issueResult.Success) {
                    Write-CustomLog -Level INFO -Message "GitHub issue created: $($issueResult.IssueUrl)"
                }
            }
            
            if ($BlockCommit) { 
                return @{ Success = $false; Message = "Direct commits to main branch blocked"; ExitCode = 1 } 
            }
        }
        
        # Step 2: Get staged files
        if (-not $StagedFiles) {
            $StagedFiles = git diff --cached --name-only --diff-filter=ACM 2>$null
        }
        
        if (-not $StagedFiles -or $StagedFiles.Count -eq 0) {
            Write-CustomLog -Level INFO -Message "No files staged for commit"
            return @{ Success = $true; Message = "No files to validate"; ExitCode = 0 }
        }
        
        $powerShellFiles = $StagedFiles | Where-Object { $_ -match '\.ps1$|\.psm1$|\.psd1$' }
        Write-CustomLog -Level INFO -Message "Validating $($StagedFiles.Count) staged files ($($powerShellFiles.Count) PowerShell)"
        
        # Step 3: Error detection
        $errors = @()
        $false # ValidationOnly removeded = @()
        
        foreach ($file in $powerShellFiles) {
            if (-not (Test-Path $file)) { continue }
            
            Write-CustomLog -Level INFO -Message "Checking: $file"
            
            try {
                $content = Get-Content $file -Raw -ErrorAction Stop
                
                # Check for syntax errors
                $syntaxErrors = @()
                
                # Empty Parameter() attributes
                if ($content -match '\[Parameter\(\s*\)') {
                    $syntaxErrors += @{
                        Type = "EMPTY_PARAMETER"
                        Message = "Empty Parameter() attribute"
                        Pattern = '\[Parameter\(\s*\)'
                        Fix = '[Parameter()]'
                        VALIDATIONable = $true
                    }
                }
                
                # Invalid Math class syntax
                if ($content -match '\bmath::') {
                    $syntaxErrors += @{
                        Type = "INVALID_MATH_SYNTAX"
                        Message = "Invalid Math class syntax (use [Math]::)"
                        Pattern = '\bmath::'
                        Fix = '[Math]::'
                        VALIDATIONable = $true
                    }
                }
                
                # Invalid variable syntax $var$index
                if ($content -match '\$\w+\$\w+') {
                    $syntaxErrors += @{
                        Type = "INVALID_VARIABLE_SYNTAX"
                        Message = "Invalid variable syntax (missing brackets)"
                        Pattern = '\$(\w+)\$(\w+)'
                        Fix = '$$$1[$$2]'
                        VALIDATIONable = $true
                    }
                }
                
                # Add errors to collection
                foreach ($syntaxError in $syntaxErrors) {
                    $errors += @{
                        File = $file
                        Type = $syntaxError.Type
                        Message = $syntaxError.Message
                        Pattern = $syntaxError.Pattern
                        Fix = $syntaxError.Fix
                        VALIDATIONable = $syntaxError.VALIDATIONable
                    }
                }
                
                # Parse validation
                try {
                    $null = [System.Management.Automation.PSParser]::Tokenize($content, [ref]$null)
                } catch {
                    $errors += @{
                        File = $file
                        Type = "PARSE_ERROR"
                        Message = $_.Exception.Message
                        Pattern = $null
                        Fix = $null
                        VALIDATIONable = $false
                    }
                }
                
            } catch {
                $errors += @{
                    File = $file
                    Type = "READ_ERROR"
                    Message = "Cannot read file: $($_.Exception.Message)"
                    Pattern = $null
                    Fix = $null
                    VALIDATIONable = $false
                }
            }
        }
        
        # Step 4: validation-only errors if requested
        if ($false # ValidationOnly removed) {
            $fixableErrors = $errors | Where-Object { $_.VALIDATIONable -eq $true }
            
            foreach ($error in $fixableErrors) {
                try {
                    $content = Get-Content $error.File -Raw
                    $originalContent = $content
                    
                    if ($error.Pattern -and $error.Fix) {
                        $content = $content -replace $error.Pattern, $error.Fix
                        
                        if ($content -ne $originalContent) {
                            Set-Content $error.File $content -NoNewline
                            git add $error.File 2>$null
                            $false # ValidationOnly removeded += "Fixed $($error.Type) in $($error.File)"
                            Write-CustomLog -Level SUCCESS -Message "validation-onlyed $($error.Type) in $($error.File)"
                        }
                    }
                } catch {
                    Write-CustomLog -Level ERROR -Message "validation-only failed for $($error.File): $($_.Exception.Message)"
                }
            }
        }
        
        # Step 5: Check remaining errors
        $remainingErrors = $errors | Where-Object { 
            $_.VALIDATIONable -eq $false -or 
            $_.File -notin ($false # ValidationOnly removeded | ForEach-Object { ($_ -split ' in ')[-1] }) 
        }
        
        # Step 6: Create GitHub issue if errors remain and CreateIssue is requested
        if ($remainingErrors.Count -gt 0 -and $CreateIssue) {
            try {
                $issueResult = New-GitHubIssue -Title "Pre-commit validation: $($remainingErrors.Count) critical errors" -Body @"
## Pre-commit Validation Report

**Branch:** $currentBranch
**Date:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
**Errors:** $($remainingErrors.Count)
**validation-onlyes:** $($false # ValidationOnly removeded.Count)

### Critical Errors:
$(foreach ($error in $remainingErrors) {
"- **$($error.File)**: $($error.Message)"
})

### validation-onlyes Applied:
$(if ($false # ValidationOnly removeded.Count -gt 0) {
foreach ($fix in $false # ValidationOnly removeded) { "- $fix" }
} else { "None" })

### Resolution:
1. Fix critical errors above
2. Re-run validation
3. Commit via PatchManager workflow

**Auto-generated by PatchManager pre-commit validation**
"@ -Labels @("validation-error", "pre-commit", "bug")
                
                if ($issueResult.Success) {
                    Write-CustomLog -Level INFO -Message "GitHub issue created: $($issueResult.IssueUrl)"
                }
            } catch {
                Write-CustomLog -Level WARN -Message "Could not create GitHub issue: $($_.Exception.Message)"
            }
        }
        
        # Step 7: Return results
        if ($remainingErrors.Count -gt 0) {
            Write-CustomLog -Level ERROR -Message "$($remainingErrors.Count) critical errors found"
            foreach ($error in $remainingErrors) {
                Write-CustomLog -Level ERROR -Message "$($error.File): $($error.Message)"
            }
            
            if ($BlockCommit) {
                Write-CustomLog -Level ERROR -Message "COMMIT BLOCKED - Fix errors and retry"
                return @{ 
                    Success = $false
                    Message = "Critical errors found"
                    ExitCode = 1
                    Errors = $remainingErrors
                    ValidationOnlyed = $false # ValidationOnly removeded
                }
            }
        }
        
        # Success
        Write-CustomLog -Level SUCCESS -Message "Pre-commit validation passed"
        if ($false # ValidationOnly removeded.Count -gt 0) {
            Write-CustomLog -Level INFO -Message "$($false # ValidationOnly removeded.Count) issues validation-onlyed"
        }
        
        return @{
            Success = $true
            Message = "Validation passed"
            ExitCode = 0
            Errors = @()
            ValidationOnlyed = $false # ValidationOnly removeded
        }
        
    } catch {
        Write-CustomLog -Level ERROR -Message "Pre-commit validation failed: $($_.Exception.Message)"
        
        if ($CreateIssue) {
            try {
                $issueResult = New-GitHubIssue -Title "Pre-commit validation system error" -Body @"
## Pre-commit Validation System Error

**Branch:** $currentBranch
**Error:** $($_.Exception.Message)
**Stack:** $($_.ScriptStackTrace)

### Action Required:
Fix the pre-commit validation system error and retry.

**Auto-generated by PatchManager pre-commit validation**
"@ -Labels @("system-error", "pre-commit", "bug")
            } catch {
                Write-CustomLog -Level WARN -Message "Could not create error issue: $($_.Exception.Message)"
            }
        }
        
        return @{
            Success = $false
            Message = "System error: $($_.Exception.Message)"
            ExitCode = 2
            Errors = @()
            ValidationOnlyed = @()
        }
    }
}

# Helper function for GitHub issue creation
function New-GitHubIssue {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Title,
        
        [Parameter(Mandatory = $true)]
        [string]$Body,
        
        [Parameter(Mandatory = $false)]
        [string[]]$Labels = @()
    )
    
    try {
        if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            return @{ Success = $false; Message = "GitHub CLI not available" }
        }
        
        $labelArgs = if ($Labels.Count -gt 0) { "--label", ($Labels -join ",") } else { @() }
        
        $result = & gh issue create --title $Title --body $Body @labelArgs 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            return @{ Success = $true; IssueUrl = $result.Trim() }
        } else {
            return @{ Success = $false; Message = "GitHub CLI error: $result" }
        }
    } catch {
        return @{ Success = $false; Message = $_.Exception.Message }
    }
}

Export-ModuleMember -Function Invoke-EnhancedPreCommitValidation
