#Requires -Version 7.0
<#
.SYNOPSIS
Install and manage integrated PatchManager pre-commit hooks with anti-recursive protection

.DESCRIPTION
Provides installation and management of pre-commit hooks that are fully integrated with
PatchManager's anti-recursive branching logic and comprehensive error handling.

.PARAMETER Install
Install the integrated pre-commit hook

.PARAMETER Uninstall
Uninstall the pre-commit hook

.PARAMETER Test
Test the pre-commit hook functionality

.PARAMETER Force
Force installation even if hook already exists

.EXAMPLE
Install-IntegratedPreCommitHook -Install

.EXAMPLE
Install-IntegratedPreCommitHook -Test

.NOTES
- Integrates directly with PatchManager module
- Enforces anti-recursive branching logic
- Creates GitHub issues for unresolved problems
- No emojis - technical output only
#>

function Install-IntegratedPreCommitHook {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $false)]
        [switch]$Install,
        
        [Parameter(Mandatory = $false)]
        [switch]$Uninstall,
        
        [Parameter(Mandatory = $false)]
        [switch]$Test,
        
        [Parameter(Mandatory = $false)]
        [switch]$Force
    )
    
    $gitHooksDir = ".git/hooks"
    $preCommitPath = "$gitHooksDir/pre-commit"
    
    if ($Install) {
        # Validate we're in a git repository
        if (-not (Test-Path $gitHooksDir)) {
            Write-CustomLog -Level ERROR -Message "Not in a git repository root directory"
            return @{ Success = $false; Message = "Not in git repository" }
        }
        
        # Check if hook already exists
        if ((Test-Path $preCommitPath) -and -not $Force) {
            Write-CustomLog -Level WARN -Message "Pre-commit hook already exists. Use -Force to overwrite"
            return @{ Success = $false; Message = "Hook already exists" }
        }
        
        # Create the integrated hook content
        $hookContent = @'
#!/usr/bin/env pwsh
#Requires -Version 7.0
# Integrated PatchManager Pre-Commit Hook
# Auto-generated - do not edit manually

$ErrorActionPreference = 'Stop'

# Initialize environment
if (-not $env:PROJECT_ROOT) { $env:PROJECT_ROOT = $PWD }
if (-not $env:PWSH_MODULES_PATH) { $env:PWSH_MODULES_PATH = "$env:PROJECT_ROOT/pwsh/modules" }

try {
    # Import PatchManager module
    Import-Module "PatchManager" -Force -ErrorAction Stop
    
    # Run integrated pre-commit validation
    $result = Invoke-EnhancedPreCommitValidation  -CreateIssue -BlockCommit
    
    if (-not $result.Success) {
        Write-Host "Pre-commit validation failed: $($result.Message)" -ForegroundColor Red
        if ($result.Errors.Count -gt 0) {
            Write-Host "Critical errors found:" -ForegroundColor Red
            foreach ($error in $result.Errors) {
                Write-Host "  $($error.File): $($error.Message)" -ForegroundColor Red
            }
        }
        exit $result.ExitCode
    }
    
    if ($result.ValidationOnlyed.Count -gt 0) {
        Write-Host "validation-onlyed $($result.ValidationOnlyed.Count) issues" -ForegroundColor Green
        foreach ($fix in $result.ValidationOnlyed) {
            Write-Host "  $fix" -ForegroundColor Gray
        }
    }
    
    Write-Host "Pre-commit validation passed" -ForegroundColor Green
    exit 0
    
} catch {
    Write-Host "Pre-commit hook error: $($_.Exception.Message)" -ForegroundColor Red
    
    # Create emergency issue if possible
    try {
        if (Get-Command gh -ErrorAction SilentlyContinue) {
            $errorTitle = "Pre-commit hook system error"
            $errorBody = @"
## Pre-commit Hook System Error

**Error:** $($_.Exception.Message)
**Stack:** $($_.ScriptStackTrace)
**Branch:** $(git rev-parse --abbrev-ref HEAD 2>$null)

### Action Required:
Fix the pre-commit hook system error.

**Auto-generated by integrated pre-commit hook**
"@
            gh issue create --title $errorTitle --body $errorBody --label "system-error,pre-commit,urgent" 2>$null
        }
    } catch {
        # Ignore issue creation errors in emergency scenarios
    }
    
    exit 2
}
'@
        
        # Write the hook file
        Set-Content -Path $preCommitPath -Value $hookContent -Encoding UTF8
        
        # Make executable (cross-platform)
        if ($env:PLATFORM -ne "Windows") {
            chmod +x $preCommitPath
        }
        
        Write-CustomLog -Level SUCCESS -Message "Integrated pre-commit hook installed successfully"
        Write-CustomLog -Level INFO -Message "Hook location: $preCommitPath"
        
        return @{ Success = $true; Message = "Hook installed"; HookPath = $preCommitPath }
    }
    
    if ($Uninstall) {
        if (Test-Path $preCommitPath) {
            Remove-Item $preCommitPath -Force
            Write-CustomLog -Level SUCCESS -Message "Pre-commit hook removed"
            return @{ Success = $true; Message = "Hook removed" }
        } else {
            Write-CustomLog -Level INFO -Message "No pre-commit hook found"
            return @{ Success = $true; Message = "No hook to remove" }
        }
    }
    
    if ($Test) {
        Write-CustomLog -Level INFO -Message "Testing integrated pre-commit hook functionality"
        
        # Test 1: Check PatchManager module availability
        try {
            Import-Module "PatchManager" -Force -ErrorAction Stop
            Write-CustomLog -Level SUCCESS -Message "PatchManager module loaded successfully"
        } catch {
            Write-CustomLog -Level ERROR -Message "PatchManager module not available: $($_.Exception.Message)"
            return @{ Success = $false; Message = "PatchManager module unavailable" }
        }
        
        # Test 2: Test pre-commit validation function
        try {
            $testResult = Invoke-EnhancedPreCommitValidation :$false -CreateIssue:$false -BlockCommit:$false
            Write-CustomLog -Level SUCCESS -Message "Pre-commit validation function working: $($testResult.Message)"
        } catch {
            Write-CustomLog -Level ERROR -Message "Pre-commit validation function error: $($_.Exception.Message)"
            return @{ Success = $false; Message = "Validation function error" }
        }
        
        # Test 3: Test anti-recursive logic
        try {
            $strategy = Get-IntelligentBranchStrategy -PatchDescription "test-validation"
            Write-CustomLog -Level SUCCESS -Message "Anti-recursive branch strategy: $($strategy.Message)"
        } catch {
            Write-CustomLog -Level ERROR -Message "Branch strategy error: $($_.Exception.Message)"
            return @{ Success = $false; Message = "Branch strategy error" }
        }
        
        # Test 4: Check GitHub CLI availability
        if (Get-Command gh -ErrorAction SilentlyContinue) {
            Write-CustomLog -Level SUCCESS -Message "GitHub CLI available for issue creation"
        } else {
            Write-CustomLog -Level WARN -Message "GitHub CLI not available - issue creation disabled"
        }
        
        Write-CustomLog -Level SUCCESS -Message "All pre-commit hook tests passed"
        return @{ Success = $true; Message = "All tests passed" }
    }
    
    # Default: Show usage
    Write-CustomLog -Level INFO -Message "Integrated PatchManager Pre-Commit Hook Manager"
    Write-CustomLog -Level INFO -Message "Usage:"
    Write-CustomLog -Level INFO -Message "  Install: Install-IntegratedPreCommitHook -Install"
    Write-CustomLog -Level INFO -Message "  Uninstall: Install-IntegratedPreCommitHook -Uninstall"
    Write-CustomLog -Level INFO -Message "  Test: Install-IntegratedPreCommitHook -Test"
    Write-CustomLog -Level INFO -Message "  Force: Install-IntegratedPreCommitHook -Install -Force"
    
    return @{ Success = $true; Message = "Usage displayed" }
}

Export-ModuleMember -Function Install-IntegratedPreCommitHook
