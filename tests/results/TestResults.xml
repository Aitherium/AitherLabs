<?xml version="1.0" encoding="utf-8" standalone="no"?>
<test-results xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="nunit_schema_2.5.xsd" name="OpenTofu Lab Automation" total="508" errors="0" failures="197" not-run="8" inconclusive="2" ignored="0" skipped="1" invalid="0" date="2025-06-18" time="16:15:23">
  <environment user-domain="WZNS" nunit-version="2.5.8.0" machine-name="WZNS" cwd="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation" os-version="10.0.26100" platform="Microsoft Windows 11 Pro|C:\WINDOWS|\Device\Harddisk1\Partition3" user="alexa" clr-version="9.0.4" />
  <culture-info current-culture="en-US" current-uiculture="en-US" />
  <test-suite type="TestFixture" name="OpenTofu Lab Automation" executed="True" result="Failure" success="False" time="196.1432" asserts="0" description="Pester">
    <results>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1" executed="True" result="Failure" success="False" time="4.493" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="BackupManager Module - Core Functions" executed="True" result="Failure" success="False" time="1.7131" asserts="0" description="BackupManager Module - Core Functions">
            <results>
              <test-suite type="TestFixture" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation" executed="True" result="Success" success="True" time="1.2124" asserts="0" description="BackupManager Module - Core Functions.Invoke-BackupConsolidation">
                <results>
                  <test-case description="Should consolidate backups successfully" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation.Should consolidate backups successfully" time="0.2338" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should create backup with timestamp" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation.Should create backup with timestamp" time="0.1177" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle exclusions properly" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation.Should handle exclusions properly" time="0.1148" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle compression options" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation.Should handle compression options" time="0.1125" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle non-existent source path" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation.Should handle non-existent source path" time="0.044" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should create backup path if it doesn't exist" name="BackupManager Module - Core Functions.Invoke-BackupConsolidation.Should create backup path if it doesn't exist" time="0.5536" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup" executed="True" result="Failure" success="False" time="1.4647" asserts="0" description="BackupManager Module - Core Functions.Invoke-PermanentCleanup">
                <results>
                  <test-case description="Should clean up old backup files" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup.Should clean up old backup files" time="0.0795" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected the actual value to be greater than 0, but got 0.</message>
                      <stack-trace>at $result.FilesRemoved | Should -BeGreaterThan 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:115
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:115
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should preserve recent backup files" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup.Should preserve recent backup files" time="0.0339" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should move files to archive when specified" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup.Should move files to archive when specified" time="0.0366" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected a value, but got $null or empty.</message>
                      <stack-trace>at $archivedFiles | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:130
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:130
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle different file age thresholds" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup.Should handle different file age thresholds" time="0.0262" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle empty backup directory" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup.Should handle empty backup directory" time="0.0229" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle non-existent backup path" name="BackupManager Module - Core Functions.Invoke-PermanentCleanup.Should handle non-existent backup path" time="0.0405" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BackupManager Module - Core Functions.New-BackupExclusion" executed="True" result="Failure" success="False" time="1.5316" asserts="0" description="BackupManager Module - Core Functions.New-BackupExclusion">
                <results>
                  <test-case description="Should add new exclusion pattern" name="BackupManager Module - Core Functions.New-BackupExclusion.Should add new exclusion pattern" time="0.0165" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'Description'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:160
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should add multiple exclusion patterns" name="BackupManager Module - Core Functions.New-BackupExclusion.Should add multiple exclusion patterns" time="0.0205" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'Description'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:168
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle duplicate exclusion patterns" name="BackupManager Module - Core Functions.New-BackupExclusion.Should handle duplicate exclusion patterns" time="0.0057" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'Description'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:175
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should validate exclusion pattern format" name="BackupManager Module - Core Functions.New-BackupExclusion.Should validate exclusion pattern format" time="0.0058" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should support regex patterns" name="BackupManager Module - Core Functions.New-BackupExclusion.Should support regex patterns" time="0.0134" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'Description'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:194
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BackupManager Module - Core Functions.Get-BackupStatistics" executed="True" result="Failure" success="False" time="1.6327" asserts="0" description="BackupManager Module - Core Functions.Get-BackupStatistics">
                <results>
                  <test-case description="Should return backup statistics" name="BackupManager Module - Core Functions.Get-BackupStatistics.Should return backup statistics" time="0.0169" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:215
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should include file age analysis" name="BackupManager Module - Core Functions.Get-BackupStatistics.Should include file age analysis" time="0.0181" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:223
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle recursive directory scanning" name="BackupManager Module - Core Functions.Get-BackupStatistics.Should handle recursive directory scanning" time="0.01" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:230
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should filter by file patterns" name="BackupManager Module - Core Functions.Get-BackupStatistics.Should filter by file patterns" time="0.012" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:237
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty backup directory for statistics" name="BackupManager Module - Core Functions.Get-BackupStatistics.Should handle empty backup directory for statistics" time="0.0244" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:247
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BackupManager Module - Core Functions.Invoke-BackupMaintenance" executed="True" result="Failure" success="False" time="1.699" asserts="0" description="BackupManager Module - Core Functions.Invoke-BackupMaintenance">
                <results>
                  <test-case description="Should perform comprehensive backup maintenance" name="BackupManager Module - Core Functions.Invoke-BackupMaintenance.Should perform comprehensive backup maintenance" time="0.0167" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:258
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should include verification checks" name="BackupManager Module - Core Functions.Invoke-BackupMaintenance.Should include verification checks" time="0.0064" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should perform cleanup as part of maintenance" name="BackupManager Module - Core Functions.Invoke-BackupMaintenance.Should perform cleanup as part of maintenance" time="0.0131" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:272
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should generate maintenance report" name="BackupManager Module - Core Functions.Invoke-BackupMaintenance.Should generate maintenance report" time="0.0132" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:280
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle maintenance errors gracefully" name="BackupManager Module - Core Functions.Invoke-BackupMaintenance.Should handle maintenance errors gracefully" time="0.0111" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="BackupManager Module - Integration Tests" executed="True" result="Failure" success="False" time="3.4226" asserts="0" description="BackupManager Module - Integration Tests">
            <results>
              <test-suite type="TestFixture" name="BackupManager Module - Integration Tests.Complete Backup Workflow" executed="True" result="Failure" success="False" time="0.6842" asserts="0" description="BackupManager Module - Integration Tests.Complete Backup Workflow">
                <results>
                  <test-case description="Should execute full backup, cleanup, and maintenance cycle" name="BackupManager Module - Integration Tests.Complete Backup Workflow.Should execute full backup, cleanup, and maintenance cycle" time="0.6004" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:311
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle backup rotation properly" name="BackupManager Module - Integration Tests.Complete Backup Workflow.Should handle backup rotation properly" time="0.0718" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BackupManager Module - Integration Tests.Error Handling and Edge Cases" executed="True" result="Failure" success="False" time="1.7056" asserts="0" description="BackupManager Module - Integration Tests.Error Handling and Edge Cases">
                <results>
                  <test-case description="Should handle corrupted backup files" name="BackupManager Module - Integration Tests.Error Handling and Edge Cases.Should handle corrupted backup files" time="0.0198" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'BackupPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\BackupManager\BackupManager-Core.Tests.ps1:359
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle insufficient disk space scenarios" name="BackupManager Module - Integration Tests.Error Handling and Edge Cases.Should handle insufficient disk space scenarios" time="0.0052" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle concurrent backup operations" name="BackupManager Module - Integration Tests.Error Handling and Edge Cases.Should handle concurrent backup operations" time="0.9765" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="BackupManager Module - Performance and Reliability" executed="True" result="Success" success="True" time="3.9141" asserts="0" description="BackupManager Module - Performance and Reliability">
            <results>
              <test-suite type="TestFixture" name="BackupManager Module - Performance and Reliability.Performance Validation" executed="True" result="Success" success="True" time="0.3578" asserts="0" description="BackupManager Module - Performance and Reliability.Performance Validation">
                <results>
                  <test-case description="Should handle large file operations efficiently" name="BackupManager Module - Performance and Reliability.Performance Validation.Should handle large file operations efficiently" time="0.1401" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should scale with multiple files" name="BackupManager Module - Performance and Reliability.Performance Validation.Should scale with multiple files" time="0.1779" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BackupManager Module - Performance and Reliability.Resource Management" executed="True" result="Success" success="True" time="0.4866" asserts="0" description="BackupManager Module - Performance and Reliability.Resource Management">
                <results>
                  <test-case description="Should clean up temporary resources" name="BackupManager Module - Performance and Reliability.Resource Management.Should clean up temporary resources" time="0.1241" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\CoreApp\CoreRunner.Tests.ps1" executed="True" result="Success" success="True" time="2.2249" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\CoreApp\CoreRunner.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Core Runner Script Validation Tests" executed="True" result="Success" success="True" time="0.0323" asserts="0" description="Core Runner Script Validation Tests">
            <results>
              <test-suite type="TestFixture" name="Core Runner Script Validation Tests.Script file existence and basic validation" executed="True" result="Success" success="True" time="0.0284" asserts="0" description="Core Runner Script Validation Tests.Script file existence and basic validation">
                <results>
                  <test-case description="should have core-runner.ps1 script" name="Core Runner Script Validation Tests.Script file existence and basic validation.should have core-runner.ps1 script" time="0.0128" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have valid PowerShell syntax in core-runner.ps1" name="Core Runner Script Validation Tests.Script file existence and basic validation.should have valid PowerShell syntax in core-runner.ps1" time="0.01" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Runner Script Structure Tests" executed="True" result="Success" success="True" time="0.099" asserts="0" description="Core Runner Script Structure Tests">
            <results>
              <test-suite type="TestFixture" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation" executed="True" result="Success" success="True" time="0.0626" asserts="0" description="Core Runner Script Structure Tests.core-runner.ps1 structure validation">
                <results>
                  <test-case description="should require PowerShell 7.0 or later" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation.should require PowerShell 7.0 or later" time="0.0037" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have proper CmdletBinding with SupportsShouldProcess" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation.should have proper CmdletBinding with SupportsShouldProcess" time="0.0031" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have comprehensive parameter definitions" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation.should have comprehensive parameter definitions" time="0.0031" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have expected parameters" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation.should have expected parameters" time="0.0217" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have parameter validation attributes" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation.should have parameter validation attributes" time="0.0031" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have comprehensive help documentation" name="Core Runner Script Structure Tests.core-runner.ps1 structure validation.should have comprehensive help documentation" time="0.013" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Runner Parameter Validation Tests" executed="True" result="Success" success="True" time="1.6056" asserts="0" description="Core Runner Parameter Validation Tests">
            <results>
              <test-suite type="TestFixture" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation" executed="True" result="Success" success="True" time="1.5029" asserts="0" description="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation">
                <results>
                  <test-case description="should accept Quiet parameter as switch" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept Quiet parameter as switch" time="0.1574" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should accept valid Verbosity values" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept valid Verbosity values" time="0.387" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should reject invalid Verbosity values" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should reject invalid Verbosity values" time="0.0249" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should accept ConfigFile parameter" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept ConfigFile parameter" time="0.1262" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should accept Auto parameter as switch" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept Auto parameter as switch" time="0.1591" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should accept Scripts parameter" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept Scripts parameter" time="0.1332" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should accept Force parameter as switch" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept Force parameter as switch" time="0.1393" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should accept NonInteractive parameter as switch" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should accept NonInteractive parameter as switch" time="0.1251" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should support parameter sets correctly" name="Core Runner Parameter Validation Tests.core-runner.ps1 parameter validation.should support parameter sets correctly" time="0.2464" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Runner Cross-Platform Compatibility Tests" executed="True" result="Success" success="True" time="1.6589" asserts="0" description="Core Runner Cross-Platform Compatibility Tests">
            <results>
              <test-suite type="TestFixture" name="Core Runner Cross-Platform Compatibility Tests.Path handling and platform-specific code" executed="True" result="Success" success="True" time="0.0358" asserts="0" description="Core Runner Cross-Platform Compatibility Tests.Path handling and platform-specific code">
                <results>
                  <test-case description="should not use Windows-specific path formats in core-runner.ps1" name="Core Runner Cross-Platform Compatibility Tests.Path handling and platform-specific code.should not use Windows-specific path formats in core-runner.ps1" time="0.0125" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should use environment variables for paths" name="Core Runner Cross-Platform Compatibility Tests.Path handling and platform-specific code.should use environment variables for paths" time="0.0064" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should not use Windows-specific cmdlets" name="Core Runner Cross-Platform Compatibility Tests.Path handling and platform-specific code.should not use Windows-specific cmdlets" time="0.0131" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Core Runner Cross-Platform Compatibility Tests.PowerShell version compatibility" executed="True" result="Success" success="True" time="0.0498" asserts="0" description="Core Runner Cross-Platform Compatibility Tests.PowerShell version compatibility">
                <results>
                  <test-case description="should use PowerShell 7.0+ compatible syntax" name="Core Runner Cross-Platform Compatibility Tests.PowerShell version compatibility.should use PowerShell 7.0+ compatible syntax" time="0.0103" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Runner Error Handling Tests" executed="True" result="Success" success="True" time="1.8992" asserts="0" description="Core Runner Error Handling Tests">
            <results>
              <test-suite type="TestFixture" name="Core Runner Error Handling Tests.Error handling patterns" executed="True" result="Success" success="True" time="0.2368" asserts="0" description="Core Runner Error Handling Tests.Error handling patterns">
                <results>
                  <test-case description="should handle missing configuration files gracefully" name="Core Runner Error Handling Tests.Error handling patterns.should handle missing configuration files gracefully" time="0.109" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should validate input parameters" name="Core Runner Error Handling Tests.Error handling patterns.should validate input parameters" time="0.1201" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should set appropriate error action preference" name="Core Runner Error Handling Tests.Error handling patterns.should set appropriate error action preference" time="0.0041" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Runner Performance Tests" executed="True" result="Success" success="True" time="2.1498" asserts="0" description="Core Runner Performance Tests">
            <results>
              <test-suite type="TestFixture" name="Core Runner Performance Tests.Execution performance" executed="True" result="Success" success="True" time="0.2474" asserts="0" description="Core Runner Performance Tests.Execution performance">
                <results>
                  <test-case description="should load and validate parameters quickly" name="Core Runner Performance Tests.Execution performance.should load and validate parameters quickly" time="0.1185" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should handle multiple parameter validations efficiently" name="Core Runner Performance Tests.Execution performance.should handle multiple parameter validations efficiently" time="0.1252" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\DevEnvironment\DevEnvironment-Core.Tests.ps1" executed="True" result="Success" success="True" time="0.2654" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\DevEnvironment\DevEnvironment-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="DevEnvironment Module Tests" executed="True" result="Success" success="True" time="0.1008" asserts="0" description="DevEnvironment Module Tests">
            <results>
              <test-suite type="TestFixture" name="DevEnvironment Module Tests.Module Import" executed="True" result="Success" success="True" time="0.0808" asserts="0" description="DevEnvironment Module Tests.Module Import">
                <results>
                  <test-case description="Should import without errors" name="DevEnvironment Module Tests.Module Import.Should import without errors" time="0.0773" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="DevEnvironment Module Tests.Core Functions" executed="True" result="Success" success="True" time="0.0971" asserts="0" description="DevEnvironment Module Tests.Core Functions">
                <results>
                  <test-case description="Should have exported functions available" name="DevEnvironment Module Tests.Core Functions.Should have exported functions available" time="0.0126" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\LabRunner\LabRunner-Core.Tests.ps1" executed="True" result="Success" success="True" time="0.2654" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\LabRunner\LabRunner-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="LabRunner Module Tests" executed="True" result="Success" success="True" time="0.1393" asserts="0" description="LabRunner Module Tests">
            <results>
              <test-suite type="TestFixture" name="LabRunner Module Tests.Module Import" executed="True" result="Success" success="True" time="0.1055" asserts="0" description="LabRunner Module Tests.Module Import">
                <results>
                  <test-case description="Should import without errors" name="LabRunner Module Tests.Module Import.Should import without errors" time="0.101" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="LabRunner Module Tests.Core Functions" executed="True" result="Success" success="True" time="0.1206" asserts="0" description="LabRunner Module Tests.Core Functions">
                <results>
                  <test-case description="Should have exported functions available" name="LabRunner Module Tests.Core Functions.Should have exported functions available" time="0.0107" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="LabRunner Module Tests.Basic Functionality" executed="True" result="Success" success="True" time="0.1358" asserts="0" description="LabRunner Module Tests.Basic Functionality">
                <results>
                  <test-case description="Should handle basic operations without errors" name="LabRunner Module Tests.Basic Functionality.Should handle basic operations without errors" time="0.011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\Logging\Logging-Core.Tests.ps1" executed="True" result="Success" success="True" time="1.3522" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\Logging\Logging-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Logging Module - Core Functions" executed="True" result="Success" success="True" time="1.1972" asserts="0" description="Logging Module - Core Functions">
            <results>
              <test-suite type="TestFixture" name="Logging Module - Core Functions.Initialize-LoggingSystem" executed="True" result="Success" success="True" time="0.1342" asserts="0" description="Logging Module - Core Functions.Initialize-LoggingSystem">
                <results>
                  <test-case description="Should initialize logging system with default settings" name="Logging Module - Core Functions.Initialize-LoggingSystem.Should initialize logging system with default settings" time="0.0267" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should initialize logging system with custom log path" name="Logging Module - Core Functions.Initialize-LoggingSystem.Should initialize logging system with custom log path" time="0.0218" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should initialize logging system with custom log levels" name="Logging Module - Core Functions.Initialize-LoggingSystem.Should initialize logging system with custom log levels" time="0.0313" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should initialize logging system with trace and performance enabled" name="Logging Module - Core Functions.Initialize-LoggingSystem.Should initialize logging system with trace and performance enabled" time="0.0291" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should create log directory if it doesn't exist" name="Logging Module - Core Functions.Initialize-LoggingSystem.Should create log directory if it doesn't exist" time="0.0117" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logging Module - Core Functions.Write-CustomLog" executed="True" result="Success" success="True" time="0.5771" asserts="0" description="Logging Module - Core Functions.Write-CustomLog">
                <results>
                  <test-case description="Should write INFO level log message" name="Logging Module - Core Functions.Write-CustomLog.Should write INFO level log message" time="0.0393" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write ERROR level log message" name="Logging Module - Core Functions.Write-CustomLog.Should write ERROR level log message" time="0.0327" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write WARN level log message" name="Logging Module - Core Functions.Write-CustomLog.Should write WARN level log message" time="0.0502" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write DEBUG level log message" name="Logging Module - Core Functions.Write-CustomLog.Should write DEBUG level log message" time="0.0377" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write SUCCESS level log message" name="Logging Module - Core Functions.Write-CustomLog.Should write SUCCESS level log message" time="0.0624" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write TRACE level log message" name="Logging Module - Core Functions.Write-CustomLog.Should write TRACE level log message" time="0.0435" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write message with context" name="Logging Module - Core Functions.Write-CustomLog.Should write message with context" time="0.083" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write message with additional data" name="Logging Module - Core Functions.Write-CustomLog.Should write message with additional data" time="0.0539" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should create log file when writing first message" name="Logging Module - Core Functions.Write-CustomLog.Should create log file when writing first message" time="0.0349" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logging Module - Core Functions.Performance Tracing" executed="True" result="Success" success="True" time="0.972" asserts="0" description="Logging Module - Core Functions.Performance Tracing">
                <results>
                  <test-case description="Should start performance trace" name="Logging Module - Core Functions.Performance Tracing.Should start performance trace" time="0.0237" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should stop performance trace" name="Logging Module - Core Functions.Performance Tracing.Should stop performance trace" time="0.1352" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should measure execution time" name="Logging Module - Core Functions.Performance Tracing.Should measure execution time" time="0.1361" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle multiple concurrent traces" name="Logging Module - Core Functions.Performance Tracing.Should handle multiple concurrent traces" time="0.0948" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logging Module - Core Functions.Trace Logging" executed="True" result="Success" success="True" time="1.0831" asserts="0" description="Logging Module - Core Functions.Trace Logging">
                <results>
                  <test-case description="Should write trace log with call stack" name="Logging Module - Core Functions.Trace Logging.Should write trace log with call stack" time="0.0417" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write trace log with custom context" name="Logging Module - Core Functions.Trace Logging.Should write trace log with custom context" time="0.0653" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logging Module - Core Functions.Debug Context" executed="True" result="Success" success="True" time="1.1712" asserts="0" description="Logging Module - Core Functions.Debug Context">
                <results>
                  <test-case description="Should write debug context information" name="Logging Module - Core Functions.Debug Context.Should write debug context information" time="0.0233" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should write debug context with custom message" name="Logging Module - Core Functions.Debug Context.Should write debug context with custom message" time="0.0604" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logging Module - Core Functions.Configuration Management" executed="True" result="Success" success="True" time="1.1934" asserts="0" description="Logging Module - Core Functions.Configuration Management">
                <results>
                  <test-case description="Should get current logging configuration" name="Logging Module - Core Functions.Configuration Management.Should get current logging configuration" time="0.0041" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should set logging configuration" name="Logging Module - Core Functions.Configuration Management.Should set logging configuration" time="0.0146" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Logging Module - Error Handling" executed="True" result="Success" success="True" time="1.275" asserts="0" description="Logging Module - Error Handling">
            <results>
              <test-suite type="TestFixture" name="Logging Module - Error Handling.Invalid Parameters" executed="True" result="Success" success="True" time="0.0187" asserts="0" description="Logging Module - Error Handling.Invalid Parameters">
                <results>
                  <test-case description="Should handle invalid log level gracefully" name="Logging Module - Error Handling.Invalid Parameters.Should handle invalid log level gracefully" time="0.0032" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle null or empty messages" name="Logging Module - Error Handling.Invalid Parameters.Should handle null or empty messages" time="0.0119" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logging Module - Error Handling.File System Issues" executed="True" result="Success" success="True" time="0.0745" asserts="0" description="Logging Module - Error Handling.File System Issues">
                <results>
                  <test-case description="Should handle inaccessible log directory" name="Logging Module - Error Handling.File System Issues.Should handle inaccessible log directory" time="0.0524" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1" executed="True" result="Failure" success="False" time="5.888" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="ParallelExecution Module - Core Functions" executed="True" result="Failure" success="False" time="4.9268" asserts="0" description="ParallelExecution Module - Core Functions">
            <results>
              <test-suite type="TestFixture" name="ParallelExecution Module - Core Functions.Invoke-ParallelForEach" executed="True" result="Failure" success="False" time="0.504" asserts="0" description="ParallelExecution Module - Core Functions.Invoke-ParallelForEach">
                <results>
                  <test-case description="Should execute script block in parallel for multiple inputs" name="ParallelExecution Module - Core Functions.Invoke-ParallelForEach.Should execute script block in parallel for multiple inputs" time="0.0809" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected 2 to be found in collection @($null, $null, $null, $null, $null), but it was not found.
[1] Expected 4 to be found in collection @($null, $null, $null, $null, $null), but it was not found.
[2] Expected 6 to be found in collection @($null, $null, $null, $null, $null), but it was not found.
[3] Expected 8 to be found in collection @($null, $null, $null, $null, $null), but it was not found.
[4] Expected 10 to be found in collection @($null, $null, $null, $null, $null), but it was not found.</message>
                      <stack-trace>[0] at $results | Should -Contain 2, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:43
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:43
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $results | Should -Contain 4, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:44
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:44
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $results | Should -Contain 6, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:45
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:45
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $results | Should -Contain 8, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:46
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:46
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[4] at $results | Should -Contain 10, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:47
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:47
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should respect throttle limit" name="ParallelExecution Module - Core Functions.Invoke-ParallelForEach.Should respect throttle limit" time="0.0376" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>RuntimeException: The value of the using variable '$using:DelayMs' cannot be retrieved because it has not been set in the local session.</message>
                      <stack-trace>at Invoke-ParallelForEach&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\core-runner\modules\ParallelExecution\ParallelExecution.psm1:119
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:55
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty input collection" name="ParallelExecution Module - Core Functions.Invoke-ParallelForEach.Should handle empty input collection" time="0.1748" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle single input item" name="ParallelExecution Module - Core Functions.Invoke-ParallelForEach.Should handle single input item" time="0.1928" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected 'Processed: test', but got P.</message>
                      <stack-trace>at $results[0] | Should -Be "Processed: test", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:79
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:79
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should pass parameters to script block correctly" name="ParallelExecution Module - Core Functions.Invoke-ParallelForEach.Should pass parameters to script block correctly" time="0.0141" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'Parameters'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:90
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ParallelExecution Module - Core Functions.Start-ParallelJob and Wait-ParallelJobs" executed="True" result="Failure" success="False" time="4.7561" asserts="0" description="ParallelExecution Module - Core Functions.Start-ParallelJob and Wait-ParallelJobs">
                <results>
                  <test-case description="Should start parallel jobs successfully" name="ParallelExecution Module - Core Functions.Start-ParallelJob and Wait-ParallelJobs.Should start parallel jobs successfully" time="0.5391" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should wait for parallel jobs to complete" name="ParallelExecution Module - Core Functions.Start-ParallelJob and Wait-ParallelJobs.Should wait for parallel jobs to complete" time="1.3686" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle job timeout gracefully" name="ParallelExecution Module - Core Functions.Start-ParallelJob and Wait-ParallelJobs.Should handle job timeout gracefully" time="1.1717" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should pass arguments to parallel jobs" name="ParallelExecution Module - Core Functions.Start-ParallelJob and Wait-ParallelJobs.Should pass arguments to parallel jobs" time="1.169" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected 15, but got $null.</message>
                      <stack-trace>at $results["JobWithArgs"] | Should -Be 15, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:148
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:148
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ParallelExecution Module - Core Functions.Invoke-ParallelPesterTests" executed="True" result="Failure" success="False" time="4.8107" asserts="0" description="ParallelExecution Module - Core Functions.Invoke-ParallelPesterTests">
                <results>
                  <test-case description="Should execute Pester tests in parallel" name="ParallelExecution Module - Core Functions.Invoke-ParallelPesterTests.Should execute Pester tests in parallel" time="0.0138" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestFiles'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle single test file" name="ParallelExecution Module - Core Functions.Invoke-ParallelPesterTests.Should handle single test file" time="0.0116" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestFiles'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:195
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should pass through Pester configuration" name="ParallelExecution Module - Core Functions.Invoke-ParallelPesterTests.Should pass through Pester configuration" time="0.0198" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected no exception to be thrown, but an exception "A parameter cannot be found that matches parameter name 'TestFiles'." was thrown from C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:209 char:42
    +             { Invoke-ParallelPesterTests -TestFiles $testFiles.FullNa …
    +                                          ~~~~~~~~~~.</message>
                      <stack-trace>at { Invoke-ParallelPesterTests -TestFiles $testFiles.FullName -PesterConfiguration $pesterConfig } | Should -Not -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:209
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:209
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ParallelExecution Module - Core Functions.Merge-ParallelTestResults" executed="True" result="Failure" success="False" time="4.9242" asserts="0" description="ParallelExecution Module - Core Functions.Merge-ParallelTestResults">
                <results>
                  <test-case description="Should merge multiple test result objects" name="ParallelExecution Module - Core Functions.Merge-ParallelTestResults.Should merge multiple test result objects" time="0.0512" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected 8, but got $null.
[1] Expected 7, but got $null.
[2] Expected 1, but got $null.
[3] Expected 0, but got $null.
[4] Expected 15, but got $null.</message>
                      <stack-trace>[0] at $merged.TotalCount | Should -Be 8, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:235
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:235
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $merged.PassedCount | Should -Be 7, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:236
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:236
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $merged.FailedCount | Should -Be 1, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:237
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:237
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $merged.SkippedCount | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:238
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:238
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[4] at $merged.Duration.TotalSeconds | Should -Be 15, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:239
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:239
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty test results array" name="ParallelExecution Module - Core Functions.Merge-ParallelTestResults.Should handle empty test results array" time="0.026" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected 0, but got $null.
[1] Expected 0, but got $null.
[2] Expected 0, but got $null.
[3] Expected 0, but got $null.</message>
                      <stack-trace>[0] at $merged.TotalCount | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:245
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:245
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $merged.PassedCount | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:246
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:246
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $merged.FailedCount | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:247
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:247
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $merged.SkippedCount | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:248
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:248
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle single test result" name="ParallelExecution Module - Core Functions.Merge-ParallelTestResults.Should handle single test result" time="0.0332" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected 2, but got $null.
[1] Expected 2, but got $null.
[2] Expected 0, but got $null.
[3] Expected 3, but got $null.</message>
                      <stack-trace>[0] at $merged.TotalCount | Should -Be 2, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:262
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:262
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $merged.PassedCount | Should -Be 2, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:263
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:263
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $merged.FailedCount | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:264
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:264
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $merged.Duration.TotalSeconds | Should -Be 3, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ParallelExecution\ParallelExecution-Core.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="ParallelExecution Module - Error Handling" executed="True" result="Success" success="True" time="5.778" asserts="0" description="ParallelExecution Module - Error Handling">
            <results>
              <test-suite type="TestFixture" name="ParallelExecution Module - Error Handling.Error Scenarios" executed="True" result="Success" success="True" time="0.0663" asserts="0" description="ParallelExecution Module - Error Handling.Error Scenarios">
                <results>
                  <test-case description="Should handle script block errors gracefully in parallel execution" name="ParallelExecution Module - Error Handling.Error Scenarios.Should handle script block errors gracefully in parallel execution" time="0.0369" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle invalid throttle limits" name="ParallelExecution Module - Error Handling.Error Scenarios.Should handle invalid throttle limits" time="0.0168" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle null script block" name="ParallelExecution Module - Error Handling.Error Scenarios.Should handle null script block" time="0.0101" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ParallelExecution Module - Error Handling.Resource Management" executed="True" result="Success" success="True" time="0.8487" asserts="0" description="ParallelExecution Module - Error Handling.Resource Management">
                <results>
                  <test-case description="Should clean up jobs properly after completion" name="ParallelExecution Module - Error Handling.Resource Management.Should clean up jobs properly after completion" time="0.779" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\BranchStrategy.Tests.ps1" executed="True" result="Failure" success="False" time="0.158" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\BranchStrategy.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="BranchStrategy Module" executed="True" result="Failure" success="False" time="0.111" asserts="0" description="BranchStrategy Module">
            <results>
              <test-suite type="TestFixture" name="BranchStrategy Module.Syntax Validation" executed="True" result="Failure" success="False" time="0.0159" asserts="0" description="BranchStrategy Module.Syntax Validation">
                <results>
                  <test-case description="Should have valid PowerShell syntax" name="BranchStrategy Module.Syntax Validation.Should have valid PowerShell syntax" time="0.0135" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected 0, but got 1.</message>
                      <stack-trace>at $errors.Count | Should -Be 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\BranchStrategy.Tests.ps1:18
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\BranchStrategy.Tests.ps1:18
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BranchStrategy Module.Get-SanitizedBranchName Function" executed="True" result="Success" success="True" time="0.0269" asserts="0" description="BranchStrategy Module.Get-SanitizedBranchName Function">
                <results>
                  <test-case description="Should sanitize branch names correctly" name="BranchStrategy Module.Get-SanitizedBranchName Function.Should sanitize branch names correctly" time="0.0031" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle custom prefix" name="BranchStrategy Module.Get-SanitizedBranchName Function.Should handle custom prefix" time="0.0012" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle no timestamp when specified" name="BranchStrategy Module.Get-SanitizedBranchName Function.Should handle no timestamp when specified" time="0.0013" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should truncate long descriptions" name="BranchStrategy Module.Get-SanitizedBranchName Function.Should truncate long descriptions" time="0.002" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BranchStrategy Module.Test-BranchProtection Function" executed="True" result="Success" success="True" time="0.045" asserts="0" description="BranchStrategy Module.Test-BranchProtection Function">
                <results>
                  <test-case description="Should protect main branches" name="BranchStrategy Module.Test-BranchProtection Function.Should protect main branches" time="0.0122" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should allow feature branches" name="BranchStrategy Module.Test-BranchProtection Function.Should allow feature branches" time="0.0031" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BranchStrategy Module.Get-IntelligentBranchStrategy Function" executed="True" result="Success" success="True" time="0.1085" asserts="0" description="BranchStrategy Module.Get-IntelligentBranchStrategy Function">
                <results>
                  <test-case description="Should generate appropriate branch name for bug fixes" name="BranchStrategy Module.Get-IntelligentBranchStrategy Function.Should generate appropriate branch name for bug fixes" time="0.0324" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should generate appropriate branch name for features" name="BranchStrategy Module.Get-IntelligentBranchStrategy Function.Should generate appropriate branch name for features" time="0.0257" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should skip branch creation when already on feature branch" name="BranchStrategy Module.Get-IntelligentBranchStrategy Function.Should skip branch creation when already on feature branch" time="0.0029" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\ErrorHandling.Tests.ps1" executed="True" result="Success" success="True" time="0.139" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\ErrorHandling.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="ErrorHandling Module" executed="True" result="Success" success="True" time="0.0697" asserts="0" description="ErrorHandling Module">
            <results>
              <test-suite type="TestFixture" name="ErrorHandling Module.HandlePatchError function" executed="True" result="Success" success="True" time="0.0421" asserts="0" description="ErrorHandling Module.HandlePatchError function">
                <results>
                  <test-case description="Should handle patch error with all parameters" name="ErrorHandling Module.HandlePatchError function.Should handle patch error with all parameters" time="0.0095" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle error without issue number" name="ErrorHandling Module.HandlePatchError function.Should handle error without issue number" time="0.0035" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle error without error record" name="ErrorHandling Module.HandlePatchError function.Should handle error without error record" time="0.0065" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should return structured error object" name="ErrorHandling Module.HandlePatchError function.Should return structured error object" time="0.006" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should send GitHub issue comment when IssueNumber provided" name="ErrorHandling Module.HandlePatchError function.Should send GitHub issue comment when IssueNumber provided" time="0.005" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should validate error categories" name="ErrorHandling Module.HandlePatchError function.Should validate error categories" time="0.009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ErrorHandling Module.Write-PatchLog function" executed="True" result="Success" success="True" time="0.0664" asserts="0" description="ErrorHandling Module.Write-PatchLog function">
                <results>
                  <test-case description="Should write log message with default level" name="ErrorHandling Module.Write-PatchLog function.Should write log message with default level" time="0.0038" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should accept different log levels" name="ErrorHandling Module.Write-PatchLog function.Should accept different log levels" time="0.0081" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle empty message" name="ErrorHandling Module.Write-PatchLog function.Should handle empty message" time="0.003" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle null message gracefully" name="ErrorHandling Module.Write-PatchLog function.Should handle null message gracefully" time="0.003" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should accept custom log file path" name="ErrorHandling Module.Write-PatchLog function.Should accept custom log file path" time="0.0039" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-BranchManagement.Tests.ps1" executed="True" result="Failure" success="False" time="0.2364" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-BranchManagement.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="PatchManager Branch Management" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Branch Management">
            <results>
              <test-suite type="TestFixture" name="PatchManager Branch Management.Get-IntelligentBranchStrategy" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Branch Management.Get-IntelligentBranchStrategy">
                <results>
                  <test-case description="Should create strategy for new patch" name="PatchManager Branch Management.Get-IntelligentBranchStrategy.Should create strategy for new patch" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle force new branch parameter" name="PatchManager Branch Management.Get-IntelligentBranchStrategy.Should handle force new branch parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should detect protected branches" name="PatchManager Branch Management.Get-IntelligentBranchStrategy.Should detect protected branches" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Branch Management.Test-BranchProtection" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Branch Management.Test-BranchProtection">
                <results>
                  <test-case description="Should identify protected branches" name="PatchManager Branch Management.Test-BranchProtection.Should identify protected branches" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should allow feature branches" name="PatchManager Branch Management.Test-BranchProtection.Should allow feature branches" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle custom protected patterns" name="PatchManager Branch Management.Test-BranchProtection.Should handle custom protected patterns" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Branch Management.Get-SanitizedBranchName" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Branch Management.Get-SanitizedBranchName">
                <results>
                  <test-case description="Should sanitize branch names properly" name="PatchManager Branch Management.Get-SanitizedBranchName.Should sanitize branch names properly" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should include timestamp by default" name="PatchManager Branch Management.Get-SanitizedBranchName.Should include timestamp by default" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should exclude timestamp when requested" name="PatchManager Branch Management.Get-SanitizedBranchName.Should exclude timestamp when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should use custom prefix" name="PatchManager Branch Management.Get-SanitizedBranchName.Should use custom prefix" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-Core.Tests.ps1" executed="True" result="Failure" success="False" time="0.2229" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="PatchManager Core Functions" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Core Functions">
            <results>
              <test-suite type="TestFixture" name="PatchManager Core Functions.Test-PatchingRequirements" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Core Functions.Test-PatchingRequirements">
                <results>
                  <test-case description="Should validate basic patching requirements" name="PatchManager Core Functions.Test-PatchingRequirements.Should validate basic patching requirements" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should return proper structure with required properties" name="PatchManager Core Functions.Test-PatchingRequirements.Should return proper structure with required properties" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Core Functions.Invoke-GitControlledPatch" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Core Functions.Invoke-GitControlledPatch">
                <results>
                  <test-case description="Should require PatchDescription parameter" name="PatchManager Core Functions.Invoke-GitControlledPatch.Should require PatchDescription parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should accept DryRun parameter" name="PatchManager Core Functions.Invoke-GitControlledPatch.Should accept DryRun parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should validate working tree when not forced" name="PatchManager Core Functions.Invoke-GitControlledPatch.Should validate working tree when not forced" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Core Functions.Invoke-EnhancedPatchManager" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Core Functions.Invoke-EnhancedPatchManager">
                <results>
                  <test-case description="Should require PatchDescription parameter" name="PatchManager Core Functions.Invoke-EnhancedPatchManager.Should require PatchDescription parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should accept AutoValidate parameter" name="PatchManager Core Functions.Invoke-EnhancedPatchManager.Should accept AutoValidate parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should accept CreatePullRequest parameter" name="PatchManager Core Functions.Invoke-EnhancedPatchManager.Should accept CreatePullRequest parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Core Functions.Set-PatchManagerAliases" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Core Functions.Set-PatchManagerAliases">
                <results>
                  <test-case description="Should set up aliases without error" name="PatchManager Core Functions.Set-PatchManagerAliases.Should set up aliases without error" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should display aliases when requested" name="PatchManager Core Functions.Set-PatchManagerAliases.Should display aliases when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should remove aliases when requested" name="PatchManager Core Functions.Set-PatchManagerAliases.Should remove aliases when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Core Functions.Invoke-QuickRollback" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Core Functions.Invoke-QuickRollback">
                <results>
                  <test-case description="Should accept RollbackType parameter" name="PatchManager Core Functions.Invoke-QuickRollback.Should accept RollbackType parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should accept CreateBackup parameter" name="PatchManager Core Functions.Invoke-QuickRollback.Should accept CreateBackup parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Integration Tests" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Integration Tests">
            <results>
              <test-suite type="TestFixture" name="PatchManager Integration Tests.Module Loading" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Integration Tests.Module Loading">
                <results>
                  <test-case description="Should have imported PatchManager functions" name="PatchManager Integration Tests.Module Loading.Should have imported PatchManager functions" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should have core functions available" name="PatchManager Integration Tests.Module Loading.Should have core functions available" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Integration Tests.Cross-Platform Environment" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Integration Tests.Cross-Platform Environment">
                <results>
                  <test-case description="Should handle cross-platform paths correctly" name="PatchManager Integration Tests.Cross-Platform Environment.Should handle cross-platform paths correctly" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Error Handling" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling">
            <results>
              <test-suite type="TestFixture" name="PatchManager Error Handling.Invalid Parameters" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling.Invalid Parameters">
                <results>
                  <test-case description="Should handle invalid patch description gracefully" name="PatchManager Error Handling.Invalid Parameters.Should handle invalid patch description gracefully" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle invalid rollback type gracefully" name="PatchManager Error Handling.Invalid Parameters.Should handle invalid rollback type gracefully" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Error Handling.Environment Validation" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling.Environment Validation">
                <results>
                  <test-case description="Should detect missing git command" name="PatchManager Error Handling.Environment Validation.Should detect missing git command" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-GitOperations.Tests.ps1" executed="True" result="Failure" success="False" time="0.2292" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-GitOperations.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="PatchManager Git Operations" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Git Operations">
            <results>
              <test-suite type="TestFixture" name="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations">
                <results>
                  <test-case description="Should validate working tree is clean" name="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations.Should validate working tree is clean" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle dirty working tree with Force parameter" name="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations.Should handle dirty working tree with Force parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should create new branch for patch" name="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations.Should create new branch for patch" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should execute patch operation" name="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations.Should execute patch operation" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should create pull request when requested" name="PatchManager Git Operations.Invoke-GitControlledPatch - Basic Operations.Should create pull request when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Git Operations.Invoke-GitControlledPatch - Advanced Features" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Git Operations.Invoke-GitControlledPatch - Advanced Features">
                <results>
                  <test-case description="Should handle affected files parameter" name="PatchManager Git Operations.Invoke-GitControlledPatch - Advanced Features.Should handle affected files parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should skip validation when requested" name="PatchManager Git Operations.Invoke-GitControlledPatch - Advanced Features.Should skip validation when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle custom base branch" name="PatchManager Git Operations.Invoke-GitControlledPatch - Advanced Features.Should handle custom base branch" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should auto-commit uncommitted changes when requested" name="PatchManager Git Operations.Invoke-GitControlledPatch - Advanced Features.Should auto-commit uncommitted changes when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Git Operations.New-PatchBranch Helper Function" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Git Operations.New-PatchBranch Helper Function">
                <results>
                  <test-case description="Should create branch with intelligent naming" name="PatchManager Git Operations.New-PatchBranch Helper Function.Should create branch with intelligent naming" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle branch name conflicts" name="PatchManager Git Operations.New-PatchBranch Helper Function.Should handle branch name conflicts" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should respect custom prefix" name="PatchManager Git Operations.New-PatchBranch Helper Function.Should respect custom prefix" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Git Operations.New-PatchCommit Helper Function" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Git Operations.New-PatchCommit Helper Function">
                <results>
                  <test-case description="Should create commit with proper format" name="PatchManager Git Operations.New-PatchCommit Helper Function.Should create commit with proper format" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty affected files" name="PatchManager Git Operations.New-PatchCommit Helper Function.Should handle empty affected files" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should include Co-authored-by when specified" name="PatchManager Git Operations.New-PatchCommit Helper Function.Should include Co-authored-by when specified" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Enhanced Git Operations" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Enhanced Git Operations">
            <results>
              <test-suite type="TestFixture" name="PatchManager Enhanced Git Operations.Invoke-EnhancedGitOperations" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Enhanced Git Operations.Invoke-EnhancedGitOperations">
                <results>
                  <test-case description="Should perform comprehensive validation" name="PatchManager Enhanced Git Operations.Invoke-EnhancedGitOperations.Should perform comprehensive validation" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle conflict resolution" name="PatchManager Enhanced Git Operations.Invoke-EnhancedGitOperations.Should handle conflict resolution" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should cleanup problematic directories" name="PatchManager Enhanced Git Operations.Invoke-EnhancedGitOperations.Should cleanup problematic directories" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Enhanced Git Operations.Git Conflict Resolution" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Enhanced Git Operations.Git Conflict Resolution">
                <results>
                  <test-case description="Should detect merge conflicts" name="PatchManager Enhanced Git Operations.Git Conflict Resolution.Should detect merge conflicts" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should attempt automatic conflict resolution" name="PatchManager Enhanced Git Operations.Git Conflict Resolution.Should attempt automatic conflict resolution" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager GitHub Integration" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager GitHub Integration">
            <results>
              <test-suite type="TestFixture" name="PatchManager GitHub Integration.Pull Request Creation" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager GitHub Integration.Pull Request Creation">
                <results>
                  <test-case description="Should create PR with proper formatting" name="PatchManager GitHub Integration.Pull Request Creation.Should create PR with proper formatting" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should include validation results in PR body" name="PatchManager GitHub Integration.Pull Request Creation.Should include validation results in PR body" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager GitHub Integration.Issue Creation" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager GitHub Integration.Issue Creation">
                <results>
                  <test-case description="Should create GitHub issue for patch tracking" name="PatchManager GitHub Integration.Issue Creation.Should create GitHub issue for patch tracking" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager GitHub Integration.Invoke-GitHubIssueIntegration" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager GitHub Integration.Invoke-GitHubIssueIntegration">
                <results>
                  <test-case description="Should integrate with existing issues" name="PatchManager GitHub Integration.Invoke-GitHubIssueIntegration.Should integrate with existing issues" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should create new issue if none specified" name="PatchManager GitHub Integration.Invoke-GitHubIssueIntegration.Should create new issue if none specified" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Error Handling in Git Operations" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling in Git Operations">
            <results>
              <test-suite type="TestFixture" name="PatchManager Error Handling in Git Operations.Git Command Failures" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling in Git Operations.Git Command Failures">
                <results>
                  <test-case description="Should handle git checkout failures gracefully" name="PatchManager Error Handling in Git Operations.Git Command Failures.Should handle git checkout failures gracefully" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle git commit failures gracefully" name="PatchManager Error Handling in Git Operations.Git Command Failures.Should handle git commit failures gracefully" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Error Handling in Git Operations.GitHub CLI Failures" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling in Git Operations.GitHub CLI Failures">
                <results>
                  <test-case description="Should handle gh authentication failures" name="PatchManager Error Handling in Git Operations.GitHub CLI Failures.Should handle gh authentication failures" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle PR creation failures" name="PatchManager Error Handling in Git Operations.GitHub CLI Failures.Should handle PR creation failures" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-Validation.Tests.ps1" executed="True" result="Failure" success="False" time="0.2219" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\PatchManager\PatchManager-Validation.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="PatchManager Validation Functions" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Validation Functions">
            <results>
              <test-suite type="TestFixture" name="PatchManager Validation Functions.Test-PatchingRequirements" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Validation Functions.Test-PatchingRequirements">
                <results>
                  <test-case description="Should detect available PowerShell modules" name="PatchManager Validation Functions.Test-PatchingRequirements.Should detect available PowerShell modules" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should detect missing PowerShell modules" name="PatchManager Validation Functions.Test-PatchingRequirements.Should detect missing PowerShell modules" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should detect available commands" name="PatchManager Validation Functions.Test-PatchingRequirements.Should detect available commands" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should detect missing commands" name="PatchManager Validation Functions.Test-PatchingRequirements.Should detect missing commands" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should provide fix suggestions for missing requirements" name="PatchManager Validation Functions.Test-PatchingRequirements.Should provide fix suggestions for missing requirements" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should install missing modules when requested" name="PatchManager Validation Functions.Test-PatchingRequirements.Should install missing modules when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should validate affected files when provided" name="PatchManager Validation Functions.Test-PatchingRequirements.Should validate affected files when provided" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should write to log file when specified" name="PatchManager Validation Functions.Test-PatchingRequirements.Should write to log file when specified" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Validation Functions.Invoke-PatchValidation" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Validation Functions.Invoke-PatchValidation">
                <results>
                  <test-case description="Should perform comprehensive patch validation" name="PatchManager Validation Functions.Invoke-PatchValidation.Should perform comprehensive patch validation" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should validate specific files when provided" name="PatchManager Validation Functions.Invoke-PatchValidation.Should validate specific files when provided" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should perform syntax validation" name="PatchManager Validation Functions.Invoke-PatchValidation.Should perform syntax validation" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should perform module validation" name="PatchManager Validation Functions.Invoke-PatchValidation.Should perform module validation" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Rollback Functions" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Rollback Functions">
            <results>
              <test-suite type="TestFixture" name="PatchManager Rollback Functions.Invoke-QuickRollback" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Rollback Functions.Invoke-QuickRollback">
                <results>
                  <test-case description="Should rollback last commit" name="PatchManager Rollback Functions.Invoke-QuickRollback.Should rollback last commit" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should rollback to specific commit" name="PatchManager Rollback Functions.Invoke-QuickRollback.Should rollback to specific commit" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should rollback working tree changes" name="PatchManager Rollback Functions.Invoke-QuickRollback.Should rollback working tree changes" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should create backup when requested" name="PatchManager Rollback Functions.Invoke-QuickRollback.Should create backup when requested" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle force parameter" name="PatchManager Rollback Functions.Invoke-QuickRollback.Should handle force parameter" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should validate rollback safety" name="PatchManager Rollback Functions.Invoke-QuickRollback.Should validate rollback safety" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Rollback Functions.Invoke-PatchRollback" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Rollback Functions.Invoke-PatchRollback">
                <results>
                  <test-case description="Should rollback specific patch by description" name="PatchManager Rollback Functions.Invoke-PatchRollback.Should rollback specific patch by description" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should rollback patch by commit hash" name="PatchManager Rollback Functions.Invoke-PatchRollback.Should rollback patch by commit hash" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle rollback with affected files" name="PatchManager Rollback Functions.Invoke-PatchRollback.Should handle rollback with affected files" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should create restoration point" name="PatchManager Rollback Functions.Invoke-PatchRollback.Should create restoration point" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Rollback Functions.Invoke-BranchRollback" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Rollback Functions.Invoke-BranchRollback">
                <results>
                  <test-case description="Should rollback to previous branch state" name="PatchManager Rollback Functions.Invoke-BranchRollback.Should rollback to previous branch state" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle branch deletion rollback" name="PatchManager Rollback Functions.Invoke-BranchRollback.Should handle branch deletion rollback" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should rollback branch merge" name="PatchManager Rollback Functions.Invoke-BranchRollback.Should rollback branch merge" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Error Handling and Monitoring" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling and Monitoring">
            <results>
              <test-suite type="TestFixture" name="PatchManager Error Handling and Monitoring.Invoke-ErrorHandler" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling and Monitoring.Invoke-ErrorHandler">
                <results>
                  <test-case description="Should handle PowerShell errors gracefully" name="PatchManager Error Handling and Monitoring.Invoke-ErrorHandler.Should handle PowerShell errors gracefully" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should log errors appropriately" name="PatchManager Error Handling and Monitoring.Invoke-ErrorHandler.Should log errors appropriately" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should provide recovery suggestions" name="PatchManager Error Handling and Monitoring.Invoke-ErrorHandler.Should provide recovery suggestions" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PatchManager Error Handling and Monitoring.Invoke-MonitoredExecution" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Error Handling and Monitoring.Invoke-MonitoredExecution">
                <results>
                  <test-case description="Should monitor script block execution" name="PatchManager Error Handling and Monitoring.Invoke-MonitoredExecution.Should monitor script block execution" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should handle execution failures" name="PatchManager Error Handling and Monitoring.Invoke-MonitoredExecution.Should handle execution failures" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should provide execution metrics" name="PatchManager Error Handling and Monitoring.Invoke-MonitoredExecution.Should provide execution metrics" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="PatchManager Issue Tracking Integration" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Issue Tracking Integration">
            <results>
              <test-suite type="TestFixture" name="PatchManager Issue Tracking Integration.Invoke-ComprehensiveIssueTracking" executed="True" result="Failure" success="False" time="0" asserts="0" description="PatchManager Issue Tracking Integration.Invoke-ComprehensiveIssueTracking">
                <results>
                  <test-case description="Should track patch-related issues" name="PatchManager Issue Tracking Integration.Invoke-ComprehensiveIssueTracking.Should track patch-related issues" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should integrate with existing issues" name="PatchManager Issue Tracking Integration.Invoke-ComprehensiveIssueTracking.Should integrate with existing issues" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                  <test-case description="Should create automated issue tracking" name="PatchManager Issue Tracking Integration.Invoke-ComprehensiveIssueTracking.Should create automated issue tracking" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1" executed="True" result="Failure" success="False" time="0.9028" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="ScriptManager Module - Core Functions" executed="True" result="Failure" success="False" time="0.2561" asserts="0" description="ScriptManager Module - Core Functions">
            <results>
              <test-suite type="TestFixture" name="ScriptManager Module - Core Functions.Register-OneOffScript" executed="True" result="Failure" success="False" time="0.0903" asserts="0" description="ScriptManager Module - Core Functions.Register-OneOffScript">
                <results>
                  <test-case description="Should register a script successfully" name="ScriptManager Module - Core Functions.Register-OneOffScript.Should register a script successfully" time="0.0225" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should register script with description" name="ScriptManager Module - Core Functions.Register-OneOffScript.Should register script with description" time="0.0168" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should register script with parameters" name="ScriptManager Module - Core Functions.Register-OneOffScript.Should register script with parameters" time="0.0046" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle non-existent script path" name="ScriptManager Module - Core Functions.Register-OneOffScript.Should handle non-existent script path" time="0.0221" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Register-OneOffScript -ScriptPath $nonExistentPath -Name "NonExistentScript" } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:60
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:60
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty script name" name="ScriptManager Module - Core Functions.Register-OneOffScript.Should handle empty script name" time="0.0069" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Register-OneOffScript -ScriptPath $script:testScriptPath -Name "" } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:64
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:64
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle null script name" name="ScriptManager Module - Core Functions.Register-OneOffScript.Should handle null script name" time="0.014" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Register-OneOffScript -ScriptPath $script:testScriptPath -Name $null } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:68
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:68
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ScriptManager Module - Core Functions.Test-OneOffScript" executed="True" result="Failure" success="False" time="0.1571" asserts="0" description="ScriptManager Module - Core Functions.Test-OneOffScript">
                <results>
                  <test-case description="Should validate a correct PowerShell script" name="ScriptManager Module - Core Functions.Test-OneOffScript.Should validate a correct PowerShell script" time="0.0182" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at $result | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:105
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:105
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should detect non-existent script" name="ScriptManager Module - Core Functions.Test-OneOffScript.Should detect non-existent script" time="0.0034" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle script with syntax errors" name="ScriptManager Module - Core Functions.Test-OneOffScript.Should handle script with syntax errors" time="0.0062" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should validate script with parameters" name="ScriptManager Module - Core Functions.Test-OneOffScript.Should validate script with parameters" time="0.0045" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at $result | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:126
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:126
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty file path" name="ScriptManager Module - Core Functions.Test-OneOffScript.Should handle empty file path" time="0.0071" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Test-OneOffScript -ScriptPath "" } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:130
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:130
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle null file path" name="ScriptManager Module - Core Functions.Test-OneOffScript.Should handle null file path" time="0.0224" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Test-OneOffScript -ScriptPath $null } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:134
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:134
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ScriptManager Module - Core Functions.Invoke-OneOffScript" executed="True" result="Failure" success="False" time="0.2535" asserts="0" description="ScriptManager Module - Core Functions.Invoke-OneOffScript">
                <results>
                  <test-case description="Should execute a simple script successfully" name="ScriptManager Module - Core Functions.Invoke-OneOffScript.Should execute a simple script successfully" time="0.022" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected a value, but got $null or empty.</message>
                      <stack-trace>at $result | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:184
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:184
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should execute script with parameters" name="ScriptManager Module - Core Functions.Invoke-OneOffScript.Should execute script with parameters" time="0.0078" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected a value, but got $null or empty.</message>
                      <stack-trace>at $result | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:195
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:195
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle script execution errors gracefully" name="ScriptManager Module - Core Functions.Invoke-OneOffScript.Should handle script execution errors gracefully" time="0.0114" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected the value to have type [System.Management.Automation.ErrorRecord] or any of its subtypes, because Script errors should be captured, but got $null with type $null.</message>
                      <stack-trace>at $result | Should -BeOfType [System.Management.Automation.ErrorRecord] -Because "Script errors should be captured", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:202
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:202
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should execute script in separate scope" name="ScriptManager Module - Core Functions.Invoke-OneOffScript.Should execute script in separate scope" time="0.0188" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle non-existent script file" name="ScriptManager Module - Core Functions.Invoke-OneOffScript.Should handle non-existent script file" time="0.0172" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Invoke-OneOffScript -ScriptPath $nonExistentPath } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:227
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:227
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should respect timeout parameter" name="ScriptManager Module - Core Functions.Invoke-OneOffScript.Should respect timeout parameter" time="0.0132" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="ScriptManager Module - Integration Scenarios" executed="True" result="Failure" success="False" time="0.3118" asserts="0" description="ScriptManager Module - Integration Scenarios">
            <results>
              <test-suite type="TestFixture" name="ScriptManager Module - Integration Scenarios.Complete Workflow" executed="True" result="Failure" success="False" time="0.0458" asserts="0" description="ScriptManager Module - Integration Scenarios.Complete Workflow">
                <results>
                  <test-case description="Should complete register -&gt; test -&gt; invoke workflow" name="ScriptManager Module - Integration Scenarios.Complete Workflow.Should complete register -&gt; test -&gt; invoke workflow" time="0.0236" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected $true, but got $false.
[1] Expected regular expression 'Deployment successful in Production' to match $null, but it did not match.</message>
                      <stack-trace>[0] at $testResult | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:284
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:284
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $invokeResult | Should -Match "Deployment successful in Production", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:293
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:293
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle different parameter combinations" name="ScriptManager Module - Integration Scenarios.Complete Workflow.Should handle different parameter combinations" time="0.0183" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression 'Tests passed in Dev' to match $null, but it did not match.
[1] Expected regular expression 'Cleanup completed in Staging' to match $null, but it did not match.</message>
                      <stack-trace>[0] at $result | Should -Match $testCase.Expected, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:304
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:304
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $result | Should -Match $testCase.Expected, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:304
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:304
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ScriptManager Module - Integration Scenarios.Error Recovery" executed="True" result="Success" success="True" time="0.0528" asserts="0" description="ScriptManager Module - Integration Scenarios.Error Recovery">
                <results>
                  <test-case description="Should recover from script registration failures" name="ScriptManager Module - Integration Scenarios.Error Recovery.Should recover from script registration failures" time="0.0039" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="ScriptManager Module - Performance and Reliability" executed="True" result="Failure" success="False" time="0.8304" asserts="0" description="ScriptManager Module - Performance and Reliability">
            <results>
              <test-suite type="TestFixture" name="ScriptManager Module - Performance and Reliability.Performance" executed="True" result="Failure" success="False" time="0.5157" asserts="0" description="ScriptManager Module - Performance and Reliability.Performance">
                <results>
                  <test-case description="Should handle multiple rapid script registrations" name="ScriptManager Module - Performance and Reliability.Performance.Should handle multiple rapid script registrations" time="0.0428" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle concurrent script operations" name="ScriptManager Module - Performance and Reliability.Performance.Should handle concurrent script operations" time="0.4663" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $false to not be found in collection @($false, $false, $false), but it was found.</message>
                      <stack-trace>at $results | Should -Not -Contain $false, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:361
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\ScriptManager\ScriptManager-Core.Tests.ps1:361
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1" executed="True" result="Failure" success="False" time="166.1394" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="TestingFramework Module - Core Functions" executed="True" result="Failure" success="False" time="34.6196" asserts="0" description="TestingFramework Module - Core Functions">
            <results>
              <test-suite type="TestFixture" name="TestingFramework Module - Core Functions.Invoke-PesterTests" executed="True" result="Failure" success="False" time="34.553" asserts="0" description="TestingFramework Module - Core Functions.Invoke-PesterTests">
                <results>
                  <test-case description="Should execute single Pester test file" name="TestingFramework Module - Core Functions.Invoke-PesterTests.Should execute single Pester test file" time="34.5249" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected a value, but got $null or empty.
[1] Expected the actual value to be greater than 0, but got $null.</message>
                      <stack-trace>[0] at $result | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:65
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:65
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $result.TotalCount | Should -BeGreaterThan 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:66
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:66
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should execute multiple Pester test files" name="TestingFramework Module - Core Functions.Invoke-PesterTests.Should execute multiple Pester test files" time="0.004" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\SampleTest1.Tests.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:37
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should execute tests from directory" name="TestingFramework Module - Core Functions.Invoke-PesterTests.Should execute tests from directory" time="0.0028" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\SampleTest1.Tests.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:37
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should generate output file when specified" name="TestingFramework Module - Core Functions.Invoke-PesterTests.Should generate output file when specified" time="0.0028" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\SampleTest1.Tests.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:37
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle custom Pester configuration" name="TestingFramework Module - Core Functions.Invoke-PesterTests.Should handle custom Pester configuration" time="0.0026" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\SampleTest1.Tests.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:37
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle non-existent test path" name="TestingFramework Module - Core Functions.Invoke-PesterTests.Should handle non-existent test path" time="0.0065" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\SampleTest1.Tests.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:37
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation" executed="True" result="Failure" success="False" time="34.5732" asserts="0" description="TestingFramework Module - Core Functions.Invoke-SyntaxValidation">
                <results>
                  <test-case description="Should validate syntax of valid PowerShell file" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation.Should validate syntax of valid PowerShell file" time="0.0028" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\ValidScript.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should detect syntax errors in invalid PowerShell file" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation.Should detect syntax errors in invalid PowerShell file" time="0.0028" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\ValidScript.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should validate syntax of directory containing PowerShell files" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation.Should validate syntax of directory containing PowerShell files" time="0.0029" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\ValidScript.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should include PSScriptAnalyzer warnings when enabled" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation.Should include PSScriptAnalyzer warnings when enabled" time="0.0029" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\ValidScript.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle non-PowerShell files gracefully" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation.Should handle non-PowerShell files gracefully" time="0.003" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\ValidScript.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle non-existent path" name="TestingFramework Module - Core Functions.Invoke-SyntaxValidation.Should handle non-existent path" time="0.0027" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\ValidScript.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2011
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution" executed="True" result="Failure" success="False" time="34.6171" asserts="0" description="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution">
                <results>
                  <test-case description="Should execute unified test suite" name="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution.Should execute unified test suite" time="0.0053" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:243
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should include syntax validation in unified execution" name="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution.Should include syntax validation in unified execution" time="0.0061" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:254
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should generate comprehensive report" name="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution.Should generate comprehensive report" time="0.0063" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:262
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty test directory" name="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution.Should handle empty test directory" time="0.0074" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:272
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should support parallel execution" name="TestingFramework Module - Core Functions.Invoke-UnifiedTestExecution.Should support parallel execution" time="0.0086" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>ParameterBindingException: A parameter cannot be found that matches parameter name 'TestPath'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:279
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="TestingFramework Module - Integration and Performance" executed="True" result="Failure" success="False" time="67.783" asserts="0" description="TestingFramework Module - Integration and Performance">
            <results>
              <test-suite type="TestFixture" name="TestingFramework Module - Integration and Performance.Integration with Other Modules" executed="True" result="Failure" success="False" time="0.0198" asserts="0" description="TestingFramework Module - Integration and Performance.Integration with Other Modules">
                <results>
                  <test-case description="Should integrate with logging system" name="TestingFramework Module - Integration and Performance.Integration with Other Modules.Should integrate with logging system" time="0.006" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>RuntimeException: Mock data are not setup for this scope, what happened?</message>
                      <stack-trace>at Get-MockDataForCurrentScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:15311
at Mock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:14977
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:293
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should work with parallel execution module" name="TestingFramework Module - Integration and Performance.Integration with Other Modules.Should work with parallel execution module" time="0.0111" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="TestingFramework Module - Integration and Performance.Performance and Reliability" executed="True" result="Failure" success="False" time="33.1605" asserts="0" description="TestingFramework Module - Integration and Performance.Performance and Reliability">
                <results>
                  <test-case description="Should handle large numbers of test files efficiently" name="TestingFramework Module - Integration and Performance.Performance and Reliability.Should handle large numbers of test files efficiently" time="32.18" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected a value, but got $null or empty.
[1] Expected the actual value to be greater than 0, but got $null.
[2] Expected the actual value to be less than 30, but got 32.1628619.</message>
                      <stack-trace>[0] at $result | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:337
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:337
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $result.TotalCount | Should -BeGreaterThan 0, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:338
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:338
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at ($endTime - $startTime).TotalSeconds | Should -BeLessThan 30, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:340
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:340
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle concurrent test execution" name="TestingFramework Module - Integration and Performance.Performance and Reliability.Should handle concurrent test execution" time="0.9467" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected a value, but got $null or empty.
[1] Expected 3, but got 0.</message>
                      <stack-trace>[0] at $results | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:355
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:355
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $results.Count | Should -Be 3, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:356
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:356
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should recover gracefully from test failures" name="TestingFramework Module - Integration and Performance.Performance and Reliability.Should recover gracefully from test failures" time="0.0035" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\FailingTest.Tests.ps1'.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:362
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="TestingFramework Module - Error Handling" executed="True" result="Failure" success="False" time="166.0566" asserts="0" description="TestingFramework Module - Error Handling">
            <results>
              <test-suite type="TestFixture" name="TestingFramework Module - Error Handling.Invalid Inputs" executed="True" result="Failure" success="False" time="97.9759" asserts="0" description="TestingFramework Module - Error Handling.Invalid Inputs">
                <results>
                  <test-case description="Should handle null test path gracefully" name="TestingFramework Module - Error Handling.Invalid Inputs.Should handle null test path gracefully" time="31.976" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Invoke-PesterTests -TestPath $null } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:388
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:388
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle empty test path gracefully" name="TestingFramework Module - Error Handling.Invalid Inputs.Should handle empty test path gracefully" time="32.6897" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected an exception to be thrown, but no exception was thrown.</message>
                      <stack-trace>at { Invoke-PesterTests -TestPath "" } | Should -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:392
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:392
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle invalid configuration objects" name="TestingFramework Module - Error Handling.Invalid Inputs.Should handle invalid configuration objects" time="33.3015" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="TestingFramework Module - Error Handling.File System Issues" executed="True" result="Failure" success="False" time="98.2711" asserts="0" description="TestingFramework Module - Error Handling.File System Issues">
                <results>
                  <test-case description="Should handle inaccessible directories" name="TestingFramework Module - Error Handling.File System Issues.Should handle inaccessible directories" time="0.2875" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle corrupted test files" name="TestingFramework Module - Error Handling.File System Issues.Should handle corrupted test files" time="0.0046" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>DirectoryNotFoundException: Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\Corrupted.Tests.ps1'.
MethodInvocationException: Exception calling "WriteAllBytes" with "2" argument(s): "Could not find a part of the path 'C:\Users\alexa\AppData\Local\Temp\d6970422-488a-497d-9dba-9cdf6fa86795\TestScripts\Corrupted.Tests.ps1'."</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\TestingFramework\TestingFramework-Core.Tests.ps1:426
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\UnifiedMaintenance\UnifiedMaintenance-Core.Tests.ps1" executed="True" result="Failure" success="False" time="0.0546" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\modules\UnifiedMaintenance\UnifiedMaintenance-Core.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="UnifiedMaintenance Module Tests" executed="True" result="Failure" success="False" time="0" asserts="0" description="UnifiedMaintenance Module Tests">
            <results>
              <test-suite type="TestFixture" name="UnifiedMaintenance Module Tests.Module Import" executed="True" result="Failure" success="False" time="0" asserts="0" description="UnifiedMaintenance Module Tests.Module Import">
                <results>
                  <test-case description="Should import without errors" name="UnifiedMaintenance Module Tests.Module Import.Should import without errors" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="UnifiedMaintenance Module Tests.Core Functions" executed="True" result="Failure" success="False" time="0" asserts="0" description="UnifiedMaintenance Module Tests.Core Functions">
                <results>
                  <test-case description="Should have exported functions available" name="UnifiedMaintenance Module Tests.Core Functions.Should have exported functions available" time="0" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>This test should run but it did not. Most likely a setup in some parent block failed.</message>
                      <stack-trace />
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1" executed="True" result="Failure" success="False" time="1.131" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0000_Cleanup-Files Script Tests" executed="True" result="Failure" success="False" time="1.0876" asserts="0" description="0000_Cleanup-Files Script Tests">
            <results>
              <test-suite type="TestFixture" name="0000_Cleanup-Files Script Tests.Script Validation" executed="True" result="Success" success="True" time="0.0214" asserts="0" description="0000_Cleanup-Files Script Tests.Script Validation">
                <results>
                  <test-case description="Should exist" name="0000_Cleanup-Files Script Tests.Script Validation.Should exist" time="0.0018" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should have valid PowerShell syntax" name="0000_Cleanup-Files Script Tests.Script Validation.Should have valid PowerShell syntax" time="0.0033" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should have required parameters" name="0000_Cleanup-Files Script Tests.Script Validation.Should have required parameters" time="0.0095" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should import LabRunner module" name="0000_Cleanup-Files Script Tests.Script Validation.Should import LabRunner module" time="0.0022" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should use Invoke-LabStep" name="0000_Cleanup-Files Script Tests.Script Validation.Should use Invoke-LabStep" time="0.0018" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0000_Cleanup-Files Script Tests.Function Execution" executed="True" result="Failure" success="False" time="0.7444" asserts="0" description="0000_Cleanup-Files Script Tests.Function Execution">
                <results>
                  <test-case description="Should execute without errors with valid config" name="0000_Cleanup-Files Script Tests.Function Execution.Should execute without errors with valid config" time="0.4305" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle missing directories gracefully" name="0000_Cleanup-Files Script Tests.Function Execution.Should handle missing directories gracefully" time="0.1404" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should clean up test directories" name="0000_Cleanup-Files Script Tests.Function Execution.Should clean up test directories" time="0.1494" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected $false, but got $true.
[1] Expected $false, but got $true.</message>
                      <stack-trace>[0] at Test-Path $testRepoPath | Should -Be $false, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1:112
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1:112
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at Test-Path $testInfraPath | Should -Be $false, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1:113
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1:113
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0000_Cleanup-Files Script Tests.Cross-Platform Compatibility" executed="True" result="Failure" success="False" time="0.7514" asserts="0" description="0000_Cleanup-Files Script Tests.Cross-Platform Compatibility">
                <results>
                  <test-case description="Should work on Windows" name="0000_Cleanup-Files Script Tests.Cross-Platform Compatibility.Should work on Windows" time="0.0042" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>RuntimeException: Mock data are not setup for this scope, what happened?</message>
                      <stack-trace>at Get-MockDataForCurrentScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:15311
at Mock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:14977
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0000_Cleanup-Files.Tests.ps1:119
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should work on Linux/macOS" name="0000_Cleanup-Files Script Tests.Cross-Platform Compatibility.Should work on Linux/macOS" time="0.0004" asserts="0" success="False" result="Ignored" executed="False" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0000_Cleanup-Files Script Tests.Error Handling" executed="True" result="Success" success="True" time="1.085" asserts="0" description="0000_Cleanup-Files Script Tests.Error Handling">
                <results>
                  <test-case description="Should handle null config gracefully" name="0000_Cleanup-Files Script Tests.Error Handling.Should handle null config gracefully" time="0.1098" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle empty config gracefully" name="0000_Cleanup-Files Script Tests.Error Handling.Should handle empty config gracefully" time="0.1085" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should handle invalid RepoUrl" name="0000_Cleanup-Files Script Tests.Error Handling.Should handle invalid RepoUrl" time="0.1127" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0001_Reset-Git.Tests.ps1" executed="True" result="Success" success="True" time="0.1396" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0001_Reset-Git.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0001_Reset-Git Tests" executed="True" result="Success" success="True" time="0.0926" asserts="0" description="0001_Reset-Git Tests">
            <results>
              <test-suite type="TestFixture" name="0001_Reset-Git Tests.Module Loading" executed="True" result="Success" success="True" time="0.0124" asserts="0" description="0001_Reset-Git Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0001_Reset-Git Tests.Module Loading.should load required modules" time="0.0025" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0001_Reset-Git Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.016" asserts="0" description="0001_Reset-Git Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0001_Reset-Git Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0002_Setup-Directories.Tests.ps1" executed="True" result="Success" success="True" time="0.1229" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0002_Setup-Directories.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0002_Setup-Directories Tests" executed="True" result="Success" success="True" time="0.0766" asserts="0" description="0002_Setup-Directories Tests">
            <results>
              <test-suite type="TestFixture" name="0002_Setup-Directories Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="0002_Setup-Directories Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0002_Setup-Directories Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0002_Setup-Directories Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="0002_Setup-Directories Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0002_Setup-Directories Tests.Functionality Tests.should execute without errors" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0006_Install-ValidationTools.Tests.ps1" executed="True" result="Success" success="True" time="0.1172" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0006_Install-ValidationTools.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0006_Install-ValidationTools Tests" executed="True" result="Success" success="True" time="0.0775" asserts="0" description="0006_Install-ValidationTools Tests">
            <results>
              <test-suite type="TestFixture" name="0006_Install-ValidationTools Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0006_Install-ValidationTools Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0006_Install-ValidationTools Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0006_Install-ValidationTools Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="0006_Install-ValidationTools Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0006_Install-ValidationTools Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0007_Install-Go.Tests.ps1" executed="True" result="Success" success="True" time="0.1316" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0007_Install-Go.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0007_Install-Go Tests" executed="True" result="Success" success="True" time="0.0925" asserts="0" description="0007_Install-Go Tests">
            <results>
              <test-suite type="TestFixture" name="0007_Install-Go Tests.Module Loading" executed="True" result="Success" success="True" time="0.0045" asserts="0" description="0007_Install-Go Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0007_Install-Go Tests.Module Loading.should load required modules" time="0.0016" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0007_Install-Go Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0079" asserts="0" description="0007_Install-Go Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0007_Install-Go Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0008_Install-OpenTofu.Tests.ps1" executed="True" result="Success" success="True" time="0.1364" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0008_Install-OpenTofu.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0008_Install-OpenTofu Tests" executed="True" result="Success" success="True" time="0.0953" asserts="0" description="0008_Install-OpenTofu Tests">
            <results>
              <test-suite type="TestFixture" name="0008_Install-OpenTofu Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0008_Install-OpenTofu Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0008_Install-OpenTofu Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0008_Install-OpenTofu Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0146" asserts="0" description="0008_Install-OpenTofu Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0008_Install-OpenTofu Tests.Functionality Tests.should execute without errors" time="0.0084" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0009_Initialize-OpenTofu.Tests.ps1" executed="True" result="Success" success="True" time="0.1248" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0009_Initialize-OpenTofu.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0009_Initialize-OpenTofu Tests" executed="True" result="Success" success="True" time="0.0838" asserts="0" description="0009_Initialize-OpenTofu Tests">
            <results>
              <test-suite type="TestFixture" name="0009_Initialize-OpenTofu Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0009_Initialize-OpenTofu Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0009_Initialize-OpenTofu Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0009_Initialize-OpenTofu Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="0009_Initialize-OpenTofu Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0009_Initialize-OpenTofu Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0010_Prepare-HyperVProvider.Tests.ps1" executed="True" result="Success" success="True" time="0.1293" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0010_Prepare-HyperVProvider.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0010_Prepare-HyperVProvider Tests" executed="True" result="Success" success="True" time="0.081" asserts="0" description="0010_Prepare-HyperVProvider Tests">
            <results>
              <test-suite type="TestFixture" name="0010_Prepare-HyperVProvider Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="0010_Prepare-HyperVProvider Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0010_Prepare-HyperVProvider Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0010_Prepare-HyperVProvider Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="0010_Prepare-HyperVProvider Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0010_Prepare-HyperVProvider Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0100_Enable-WinRM.Tests.ps1" executed="True" result="Success" success="True" time="0.1329" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0100_Enable-WinRM.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0100_Enable-WinRM Tests" executed="True" result="Success" success="True" time="0.0872" asserts="0" description="0100_Enable-WinRM Tests">
            <results>
              <test-suite type="TestFixture" name="0100_Enable-WinRM Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="0100_Enable-WinRM Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0100_Enable-WinRM Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0100_Enable-WinRM Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0066" asserts="0" description="0100_Enable-WinRM Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0100_Enable-WinRM Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0101_Enable-RemoteDesktop.Tests.ps1" executed="True" result="Success" success="True" time="0.1159" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0101_Enable-RemoteDesktop.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0101_Enable-RemoteDesktop Tests" executed="True" result="Success" success="True" time="0.0785" asserts="0" description="0101_Enable-RemoteDesktop Tests">
            <results>
              <test-suite type="TestFixture" name="0101_Enable-RemoteDesktop Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="0101_Enable-RemoteDesktop Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0101_Enable-RemoteDesktop Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0101_Enable-RemoteDesktop Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0101" asserts="0" description="0101_Enable-RemoteDesktop Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0101_Enable-RemoteDesktop Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0102_Configure-Firewall.Tests.ps1" executed="True" result="Success" success="True" time="0.1205" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0102_Configure-Firewall.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0102_Configure-Firewall Tests" executed="True" result="Success" success="True" time="0.0806" asserts="0" description="0102_Configure-Firewall Tests">
            <results>
              <test-suite type="TestFixture" name="0102_Configure-Firewall Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0102_Configure-Firewall Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0102_Configure-Firewall Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0102_Configure-Firewall Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="0102_Configure-Firewall Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0102_Configure-Firewall Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0103_Change-ComputerName.Tests.ps1" executed="True" result="Success" success="True" time="0.1264" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0103_Change-ComputerName.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0103_Change-ComputerName Tests" executed="True" result="Success" success="True" time="0.0823" asserts="0" description="0103_Change-ComputerName Tests">
            <results>
              <test-suite type="TestFixture" name="0103_Change-ComputerName Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="0103_Change-ComputerName Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0103_Change-ComputerName Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0103_Change-ComputerName Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="0103_Change-ComputerName Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0103_Change-ComputerName Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0104_Install-CA.Tests.ps1" executed="True" result="Success" success="True" time="0.1218" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0104_Install-CA.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0104_Install-CA Tests" executed="True" result="Success" success="True" time="0.0847" asserts="0" description="0104_Install-CA Tests">
            <results>
              <test-suite type="TestFixture" name="0104_Install-CA Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="0104_Install-CA Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0104_Install-CA Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0104_Install-CA Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0072" asserts="0" description="0104_Install-CA Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0104_Install-CA Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0105_Install-HyperV.Tests.ps1" executed="True" result="Success" success="True" time="0.123" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0105_Install-HyperV.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0105_Install-HyperV Tests" executed="True" result="Success" success="True" time="0.081" asserts="0" description="0105_Install-HyperV Tests">
            <results>
              <test-suite type="TestFixture" name="0105_Install-HyperV Tests.Module Loading" executed="True" result="Success" success="True" time="0.0038" asserts="0" description="0105_Install-HyperV Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0105_Install-HyperV Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0105_Install-HyperV Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="0105_Install-HyperV Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0105_Install-HyperV Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0106_Install-WAC.Tests.ps1" executed="True" result="Success" success="True" time="0.1201" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0106_Install-WAC.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0106_Install-WAC Tests" executed="True" result="Success" success="True" time="0.0829" asserts="0" description="0106_Install-WAC Tests">
            <results>
              <test-suite type="TestFixture" name="0106_Install-WAC Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="0106_Install-WAC Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0106_Install-WAC Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0106_Install-WAC Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="0106_Install-WAC Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0106_Install-WAC Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0111_Disable-TCPIP6.Tests.ps1" executed="True" result="Success" success="True" time="0.1277" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0111_Disable-TCPIP6.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0111_Disable-TCPIP6 Tests" executed="True" result="Success" success="True" time="0.0897" asserts="0" description="0111_Disable-TCPIP6 Tests">
            <results>
              <test-suite type="TestFixture" name="0111_Disable-TCPIP6 Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="0111_Disable-TCPIP6 Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0111_Disable-TCPIP6 Tests.Module Loading.should load required modules" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0111_Disable-TCPIP6 Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0072" asserts="0" description="0111_Disable-TCPIP6 Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0111_Disable-TCPIP6 Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0112_Enable-PXE.Tests.ps1" executed="True" result="Success" success="True" time="0.1364" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0112_Enable-PXE.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0112_Enable-PXE Tests" executed="True" result="Success" success="True" time="0.0999" asserts="0" description="0112_Enable-PXE Tests">
            <results>
              <test-suite type="TestFixture" name="0112_Enable-PXE Tests.Module Loading" executed="True" result="Success" success="True" time="0.0065" asserts="0" description="0112_Enable-PXE Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0112_Enable-PXE Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0112_Enable-PXE Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0097" asserts="0" description="0112_Enable-PXE Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0112_Enable-PXE Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0113_Config-DNS.Tests.ps1" executed="True" result="Success" success="True" time="0.1251" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0113_Config-DNS.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0113_Config-DNS Tests" executed="True" result="Success" success="True" time="0.0845" asserts="0" description="0113_Config-DNS Tests">
            <results>
              <test-suite type="TestFixture" name="0113_Config-DNS Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="0113_Config-DNS Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0113_Config-DNS Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0113_Config-DNS Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="0113_Config-DNS Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0113_Config-DNS Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0114_Config-TrustedHosts.Tests.ps1" executed="True" result="Success" success="True" time="0.1235" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0114_Config-TrustedHosts.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0114_Config-TrustedHosts Tests" executed="True" result="Success" success="True" time="0.0824" asserts="0" description="0114_Config-TrustedHosts Tests">
            <results>
              <test-suite type="TestFixture" name="0114_Config-TrustedHosts Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="0114_Config-TrustedHosts Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0114_Config-TrustedHosts Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0114_Config-TrustedHosts Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0077" asserts="0" description="0114_Config-TrustedHosts Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0114_Config-TrustedHosts Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0200_Get-SystemInfo.Tests.ps1" executed="True" result="Success" success="True" time="0.1269" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0200_Get-SystemInfo.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0200_Get-SystemInfo Tests" executed="True" result="Success" success="True" time="0.0855" asserts="0" description="0200_Get-SystemInfo Tests">
            <results>
              <test-suite type="TestFixture" name="0200_Get-SystemInfo Tests.Module Loading" executed="True" result="Success" success="True" time="0.0048" asserts="0" description="0200_Get-SystemInfo Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0200_Get-SystemInfo Tests.Module Loading.should load required modules" time="0.0014" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0200_Get-SystemInfo Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0086" asserts="0" description="0200_Get-SystemInfo Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0200_Get-SystemInfo Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0201_Install-NodeCore.Tests.ps1" executed="True" result="Success" success="True" time="0.1205" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0201_Install-NodeCore.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0201_Install-NodeCore Tests" executed="True" result="Success" success="True" time="0.0812" asserts="0" description="0201_Install-NodeCore Tests">
            <results>
              <test-suite type="TestFixture" name="0201_Install-NodeCore Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0201_Install-NodeCore Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0201_Install-NodeCore Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0201_Install-NodeCore Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="0201_Install-NodeCore Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0201_Install-NodeCore Tests.Functionality Tests.should execute without errors" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0202_Install-NodeGlobalPackages.Tests.ps1" executed="True" result="Success" success="True" time="0.116" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0202_Install-NodeGlobalPackages.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0202_Install-NodeGlobalPackages Tests" executed="True" result="Success" success="True" time="0.0746" asserts="0" description="0202_Install-NodeGlobalPackages Tests">
            <results>
              <test-suite type="TestFixture" name="0202_Install-NodeGlobalPackages Tests.Module Loading" executed="True" result="Success" success="True" time="0.0033" asserts="0" description="0202_Install-NodeGlobalPackages Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0202_Install-NodeGlobalPackages Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0202_Install-NodeGlobalPackages Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0065" asserts="0" description="0202_Install-NodeGlobalPackages Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0202_Install-NodeGlobalPackages Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0203_Install-npm.Tests.ps1" executed="True" result="Success" success="True" time="0.1162" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0203_Install-npm.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0203_Install-npm Tests" executed="True" result="Success" success="True" time="0.0776" asserts="0" description="0203_Install-npm Tests">
            <results>
              <test-suite type="TestFixture" name="0203_Install-npm Tests.Module Loading" executed="True" result="Success" success="True" time="0.0038" asserts="0" description="0203_Install-npm Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0203_Install-npm Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0203_Install-npm Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.007" asserts="0" description="0203_Install-npm Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0203_Install-npm Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0204_Install-Poetry.Tests.ps1" executed="True" result="Success" success="True" time="0.1211" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0204_Install-Poetry.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0204_Install-Poetry Tests" executed="True" result="Success" success="True" time="0.0809" asserts="0" description="0204_Install-Poetry Tests">
            <results>
              <test-suite type="TestFixture" name="0204_Install-Poetry Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0204_Install-Poetry Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0204_Install-Poetry Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0204_Install-Poetry Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="0204_Install-Poetry Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0204_Install-Poetry Tests.Functionality Tests.should execute without errors" time="0.0012" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0205_Install-Sysinternals.Tests.ps1" executed="True" result="Success" success="True" time="0.1262" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0205_Install-Sysinternals.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0205_Install-Sysinternals Tests" executed="True" result="Success" success="True" time="0.0869" asserts="0" description="0205_Install-Sysinternals Tests">
            <results>
              <test-suite type="TestFixture" name="0205_Install-Sysinternals Tests.Module Loading" executed="True" result="Success" success="True" time="0.0063" asserts="0" description="0205_Install-Sysinternals Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0205_Install-Sysinternals Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0205_Install-Sysinternals Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0096" asserts="0" description="0205_Install-Sysinternals Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0205_Install-Sysinternals Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0206_Install-Python.Tests.ps1" executed="True" result="Success" success="True" time="0.1169" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0206_Install-Python.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0206_Install-Python Tests" executed="True" result="Success" success="True" time="0.075" asserts="0" description="0206_Install-Python Tests">
            <results>
              <test-suite type="TestFixture" name="0206_Install-Python Tests.Module Loading" executed="True" result="Success" success="True" time="0.0033" asserts="0" description="0206_Install-Python Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0206_Install-Python Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0206_Install-Python Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0066" asserts="0" description="0206_Install-Python Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0206_Install-Python Tests.Functionality Tests.should execute without errors" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0207_Install-Git.Tests.ps1" executed="True" result="Success" success="True" time="0.1195" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0207_Install-Git.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0207_Install-Git Tests" executed="True" result="Success" success="True" time="0.0783" asserts="0" description="0207_Install-Git Tests">
            <results>
              <test-suite type="TestFixture" name="0207_Install-Git Tests.Module Loading" executed="True" result="Success" success="True" time="0.004" asserts="0" description="0207_Install-Git Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0207_Install-Git Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0207_Install-Git Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="0207_Install-Git Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0207_Install-Git Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0208_Install-DockerDesktop.Tests.ps1" executed="True" result="Success" success="True" time="0.1194" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0208_Install-DockerDesktop.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0208_Install-DockerDesktop Tests" executed="True" result="Success" success="True" time="0.082" asserts="0" description="0208_Install-DockerDesktop Tests">
            <results>
              <test-suite type="TestFixture" name="0208_Install-DockerDesktop Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="0208_Install-DockerDesktop Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0208_Install-DockerDesktop Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0208_Install-DockerDesktop Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="0208_Install-DockerDesktop Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0208_Install-DockerDesktop Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0209_Install-7Zip.Tests.ps1" executed="True" result="Success" success="True" time="0.1223" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0209_Install-7Zip.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0209_Install-7Zip Tests" executed="True" result="Success" success="True" time="0.0843" asserts="0" description="0209_Install-7Zip Tests">
            <results>
              <test-suite type="TestFixture" name="0209_Install-7Zip Tests.Module Loading" executed="True" result="Success" success="True" time="0.007" asserts="0" description="0209_Install-7Zip Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0209_Install-7Zip Tests.Module Loading.should load required modules" time="0.0044" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0209_Install-7Zip Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0102" asserts="0" description="0209_Install-7Zip Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0209_Install-7Zip Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0210_Install-VSCode.Tests.ps1" executed="True" result="Success" success="True" time="0.1279" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0210_Install-VSCode.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0210_Install-VSCode Tests" executed="True" result="Success" success="True" time="0.0851" asserts="0" description="0210_Install-VSCode Tests">
            <results>
              <test-suite type="TestFixture" name="0210_Install-VSCode Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0210_Install-VSCode Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0210_Install-VSCode Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0210_Install-VSCode Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="0210_Install-VSCode Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0210_Install-VSCode Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0211_Install-VSBuildTools.Tests.ps1" executed="True" result="Success" success="True" time="0.114" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0211_Install-VSBuildTools.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0211_Install-VSBuildTools Tests" executed="True" result="Success" success="True" time="0.0767" asserts="0" description="0211_Install-VSBuildTools Tests">
            <results>
              <test-suite type="TestFixture" name="0211_Install-VSBuildTools Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="0211_Install-VSBuildTools Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0211_Install-VSBuildTools Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0211_Install-VSBuildTools Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="0211_Install-VSBuildTools Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0211_Install-VSBuildTools Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0212_Install-AzureCLI.Tests.ps1" executed="True" result="Success" success="True" time="0.12" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0212_Install-AzureCLI.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0212_Install-AzureCLI Tests" executed="True" result="Success" success="True" time="0.0823" asserts="0" description="0212_Install-AzureCLI Tests">
            <results>
              <test-suite type="TestFixture" name="0212_Install-AzureCLI Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0212_Install-AzureCLI Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0212_Install-AzureCLI Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0212_Install-AzureCLI Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="0212_Install-AzureCLI Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0212_Install-AzureCLI Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0213_Install-AWSCLI.Tests.ps1" executed="True" result="Success" success="True" time="0.12" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0213_Install-AWSCLI.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0213_Install-AWSCLI Tests" executed="True" result="Success" success="True" time="0.0806" asserts="0" description="0213_Install-AWSCLI Tests">
            <results>
              <test-suite type="TestFixture" name="0213_Install-AWSCLI Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="0213_Install-AWSCLI Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0213_Install-AWSCLI Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0213_Install-AWSCLI Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0103" asserts="0" description="0213_Install-AWSCLI Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0213_Install-AWSCLI Tests.Functionality Tests.should execute without errors" time="0.0043" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0214_Install-Packer.Tests.ps1" executed="True" result="Success" success="True" time="0.1225" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0214_Install-Packer.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0214_Install-Packer Tests" executed="True" result="Success" success="True" time="0.081" asserts="0" description="0214_Install-Packer Tests">
            <results>
              <test-suite type="TestFixture" name="0214_Install-Packer Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="0214_Install-Packer Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0214_Install-Packer Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0214_Install-Packer Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0066" asserts="0" description="0214_Install-Packer Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0214_Install-Packer Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0215_Install-Chocolatey.Tests.ps1" executed="True" result="Success" success="True" time="0.1148" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0215_Install-Chocolatey.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0215_Install-Chocolatey Tests" executed="True" result="Success" success="True" time="0.0774" asserts="0" description="0215_Install-Chocolatey Tests">
            <results>
              <test-suite type="TestFixture" name="0215_Install-Chocolatey Tests.Module Loading" executed="True" result="Success" success="True" time="0.0032" asserts="0" description="0215_Install-Chocolatey Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0215_Install-Chocolatey Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0215_Install-Chocolatey Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0063" asserts="0" description="0215_Install-Chocolatey Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0215_Install-Chocolatey Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0216_Set-LabProfile.Tests.ps1" executed="True" result="Success" success="True" time="0.133" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\0216_Set-LabProfile.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="0216_Set-LabProfile Tests" executed="True" result="Success" success="True" time="0.0824" asserts="0" description="0216_Set-LabProfile Tests">
            <results>
              <test-suite type="TestFixture" name="0216_Set-LabProfile Tests.Module Loading" executed="True" result="Success" success="True" time="0.0038" asserts="0" description="0216_Set-LabProfile Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="0216_Set-LabProfile Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="0216_Set-LabProfile Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="0216_Set-LabProfile Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="0216_Set-LabProfile Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\9999_Reset-Machine.Tests.ps1" executed="True" result="Success" success="True" time="0.1273" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\9999_Reset-Machine.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="9999_Reset-Machine Tests" executed="True" result="Success" success="True" time="0.0871" asserts="0" description="9999_Reset-Machine Tests">
            <results>
              <test-suite type="TestFixture" name="9999_Reset-Machine Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="9999_Reset-Machine Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="9999_Reset-Machine Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="9999_Reset-Machine Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0098" asserts="0" description="9999_Reset-Machine Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="9999_Reset-Machine Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Configure-Firewall.Tests.ps1" executed="True" result="Success" success="True" time="0.1183" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Configure-Firewall.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Configure-Firewall Tests" executed="True" result="Success" success="True" time="0.0784" asserts="0" description="Configure-Firewall Tests">
            <results>
              <test-suite type="TestFixture" name="Configure-Firewall Tests.Module Loading" executed="True" result="Success" success="True" time="0.004" asserts="0" description="Configure-Firewall Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Configure-Firewall Tests.Module Loading.should load required modules" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Configure-Firewall Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0073" asserts="0" description="Configure-Firewall Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Configure-Firewall Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Enable-PXE.Tests.ps1" executed="True" result="Success" success="True" time="0.1274" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Enable-PXE.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Enable-PXE Tests" executed="True" result="Success" success="True" time="0.083" asserts="0" description="Enable-PXE Tests">
            <results>
              <test-suite type="TestFixture" name="Enable-PXE Tests.Module Loading" executed="True" result="Success" success="True" time="0.004" asserts="0" description="Enable-PXE Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Enable-PXE Tests.Module Loading.should load required modules" time="0.0013" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Enable-PXE Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="Enable-PXE Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Enable-PXE Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Enable-RemoteDesktop.Tests.ps1" executed="True" result="Success" success="True" time="0.1215" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Enable-RemoteDesktop.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Enable-RemoteDesktop Tests" executed="True" result="Success" success="True" time="0.0837" asserts="0" description="Enable-RemoteDesktop Tests">
            <results>
              <test-suite type="TestFixture" name="Enable-RemoteDesktop Tests.Module Loading" executed="True" result="Success" success="True" time="0.004" asserts="0" description="Enable-RemoteDesktop Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Enable-RemoteDesktop Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Enable-RemoteDesktop Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0073" asserts="0" description="Enable-RemoteDesktop Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Enable-RemoteDesktop Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Enable-WinRM.Tests.ps1" executed="True" result="Success" success="True" time="0.1171" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Enable-WinRM.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Enable-WinRM Tests" executed="True" result="Success" success="True" time="0.0782" asserts="0" description="Enable-WinRM Tests">
            <results>
              <test-suite type="TestFixture" name="Enable-WinRM Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="Enable-WinRM Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Enable-WinRM Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Enable-WinRM Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="Enable-WinRM Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Enable-WinRM Tests.Functionality Tests.should execute without errors" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-HyperVProviderVersion.Tests.ps1" executed="True" result="Success" success="True" time="0.1192" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-HyperVProviderVersion.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Get-HyperVProviderVersion Tests" executed="True" result="Success" success="True" time="0.0815" asserts="0" description="Get-HyperVProviderVersion Tests">
            <results>
              <test-suite type="TestFixture" name="Get-HyperVProviderVersion Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="Get-HyperVProviderVersion Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Get-HyperVProviderVersion Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Get-HyperVProviderVersion Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="Get-HyperVProviderVersion Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Get-HyperVProviderVersion Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-LabConfig.Tests.ps1" executed="True" result="Success" success="True" time="0.1191" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-LabConfig.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Get-LabConfig Tests" executed="True" result="Success" success="True" time="0.0817" asserts="0" description="Get-LabConfig Tests">
            <results>
              <test-suite type="TestFixture" name="Get-LabConfig Tests.Module Loading" executed="True" result="Success" success="True" time="0.0033" asserts="0" description="Get-LabConfig Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Get-LabConfig Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Get-LabConfig Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="Get-LabConfig Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Get-LabConfig Tests.Functionality Tests.should execute without errors" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-Platform.Tests.ps1" executed="True" result="Success" success="True" time="0.1188" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-Platform.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Get-Platform Tests" executed="True" result="Success" success="True" time="0.0808" asserts="0" description="Get-Platform Tests">
            <results>
              <test-suite type="TestFixture" name="Get-Platform Tests.Module Loading" executed="True" result="Success" success="True" time="0.0065" asserts="0" description="Get-Platform Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Get-Platform Tests.Module Loading.should load required modules" time="0.004" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Get-Platform Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.01" asserts="0" description="Get-Platform Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Get-Platform Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-SystemInfo.Tests.ps1" executed="True" result="Success" success="True" time="0.1177" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-SystemInfo.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Get-SystemInfo Tests" executed="True" result="Success" success="True" time="0.0762" asserts="0" description="Get-SystemInfo Tests">
            <results>
              <test-suite type="TestFixture" name="Get-SystemInfo Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="Get-SystemInfo Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Get-SystemInfo Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Get-SystemInfo Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0066" asserts="0" description="Get-SystemInfo Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Get-SystemInfo Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-WindowsJobArtifacts.Tests.ps1" executed="True" result="Success" success="True" time="0.1238" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Get-WindowsJobArtifacts.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Get-WindowsJobArtifacts Tests" executed="True" result="Success" success="True" time="0.0839" asserts="0" description="Get-WindowsJobArtifacts Tests">
            <results>
              <test-suite type="TestFixture" name="Get-WindowsJobArtifacts Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="Get-WindowsJobArtifacts Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Get-WindowsJobArtifacts Tests.Module Loading.should load required modules" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Get-WindowsJobArtifacts Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="Get-WindowsJobArtifacts Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Get-WindowsJobArtifacts Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-CA.Tests.ps1" executed="True" result="Success" success="True" time="0.1456" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-CA.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-CA Tests" executed="True" result="Success" success="True" time="0.0833" asserts="0" description="Install-CA Tests">
            <results>
              <test-suite type="TestFixture" name="Install-CA Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="Install-CA Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-CA Tests.Module Loading.should load required modules" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-CA Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="Install-CA Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-CA Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-Go.Tests.ps1" executed="True" result="Success" success="True" time="0.1234" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-Go.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-Go Tests" executed="True" result="Success" success="True" time="0.0816" asserts="0" description="Install-Go Tests">
            <results>
              <test-suite type="TestFixture" name="Install-Go Tests.Module Loading" executed="True" result="Success" success="True" time="0.0065" asserts="0" description="Install-Go Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-Go Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-Go Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0097" asserts="0" description="Install-Go Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-Go Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-npm.Tests.ps1" executed="True" result="Success" success="True" time="0.1291" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-npm.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-npm Tests" executed="True" result="Success" success="True" time="0.0861" asserts="0" description="Install-npm Tests">
            <results>
              <test-suite type="TestFixture" name="Install-npm Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="Install-npm Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-npm Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-npm Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0074" asserts="0" description="Install-npm Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-npm Tests.Functionality Tests.should execute without errors" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-OpenTofu.Tests.ps1" executed="True" result="Success" success="True" time="0.1257" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-OpenTofu.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-OpenTofu Tests" executed="True" result="Success" success="True" time="0.0864" asserts="0" description="Install-OpenTofu Tests">
            <results>
              <test-suite type="TestFixture" name="Install-OpenTofu Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="Install-OpenTofu Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-OpenTofu Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-OpenTofu Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0073" asserts="0" description="Install-OpenTofu Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-OpenTofu Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-Poetry.Tests.ps1" executed="True" result="Success" success="True" time="0.1249" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-Poetry.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-Poetry Tests" executed="True" result="Success" success="True" time="0.0869" asserts="0" description="Install-Poetry Tests">
            <results>
              <test-suite type="TestFixture" name="Install-Poetry Tests.Module Loading" executed="True" result="Success" success="True" time="0.0038" asserts="0" description="Install-Poetry Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-Poetry Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-Poetry Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.007" asserts="0" description="Install-Poetry Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-Poetry Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-Sysinternals.Tests.ps1" executed="True" result="Success" success="True" time="0.1232" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-Sysinternals.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-Sysinternals Tests" executed="True" result="Success" success="True" time="0.0848" asserts="0" description="Install-Sysinternals Tests">
            <results>
              <test-suite type="TestFixture" name="Install-Sysinternals Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="Install-Sysinternals Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-Sysinternals Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-Sysinternals Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0106" asserts="0" description="Install-Sysinternals Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-Sysinternals Tests.Functionality Tests.should execute without errors" time="0.0045" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-ValidationTools.Tests.ps1" executed="True" result="Success" success="True" time="0.1158" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Install-ValidationTools.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Install-ValidationTools Tests" executed="True" result="Success" success="True" time="0.0783" asserts="0" description="Install-ValidationTools Tests">
            <results>
              <test-suite type="TestFixture" name="Install-ValidationTools Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="Install-ValidationTools Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Install-ValidationTools Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Install-ValidationTools Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="Install-ValidationTools Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Install-ValidationTools Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1" executed="True" result="Failure" success="False" time="0.9652" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Invoke-CoreApplication.ps1 Tests" executed="True" result="Failure" success="False" time="0.7429" asserts="0" description="Invoke-CoreApplication.ps1 Tests">
            <results>
              <test-suite type="TestFixture" name="Invoke-CoreApplication.ps1 Tests.Script Validation" executed="True" result="Failure" success="False" time="0.216" asserts="0" description="Invoke-CoreApplication.ps1 Tests.Script Validation">
                <results>
                  <test-case description="Should exist and be readable" name="Invoke-CoreApplication.ps1 Tests.Script Validation.Should exist and be readable" time="0.0163" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected path 'C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation/pwsh/core_app/scripts/Invoke-CoreApplication.ps1' to exist, but it did not exist.
[1] Expected a value, but got $null or empty.</message>
                      <stack-trace>[0] at $script:ScriptPath | Should -Exist, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:47
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:47
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $script:ScriptContent | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:48
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:48
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have valid PowerShell syntax" name="Invoke-CoreApplication.ps1 Tests.Script Validation.Should have valid PowerShell syntax" time="0.015" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected no exception to be thrown, but an exception "Syntax errors detected" was thrown from C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:58 char:21
    +                     throw "Syntax errors detected"
    +                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.</message>
                      <stack-trace>at } | Should -Not -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:60
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:53
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have mandatory parameter ConfigPath" name="Invoke-CoreApplication.ps1 Tests.Script Validation.Should have mandatory parameter ConfigPath" time="0.0935" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression '\[Parameter\(Mandatory=\$true\)\]' to match $null, but it did not match.
[1] Expected regular expression '\[string\]\$ConfigPath' to match $null, but it did not match.</message>
                      <stack-trace>[0] at $script:ScriptContent | Should -Match '\[Parameter\(Mandatory=\$true\)\]', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:64
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:64
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $script:ScriptContent | Should -Match '\[string\]\$ConfigPath', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:65
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:65
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should import required modules" name="Invoke-CoreApplication.ps1 Tests.Script Validation.Should import required modules" time="0.0883" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected regular expression 'Import-Module.*LabRunner' to match $null, but it did not match.</message>
                      <stack-trace>at $script:ScriptContent | Should -Match 'Import-Module.*LabRunner', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:70
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:70
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Invoke-CoreApplication.ps1 Tests.Parameter Validation" executed="True" result="Failure" success="False" time="0.4029" asserts="0" description="Invoke-CoreApplication.ps1 Tests.Parameter Validation">
                <results>
                  <test-case description="Should have proper error handling for missing config file" name="Invoke-CoreApplication.ps1 Tests.Parameter Validation.Should have proper error handling for missing config file" time="0.0918" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression 'Test-Path \$ConfigPath' to match $null, but it did not match.
[1] Expected regular expression 'Write-Error.*Configuration file not found' to match $null, but it did not match.</message>
                      <stack-trace>[0] at $script:ScriptContent | Should -Match 'Test-Path \$ConfigPath', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:77
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:77
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $script:ScriptContent | Should -Match 'Write-Error.*Configuration file not found', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:78
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:78
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should use ErrorActionPreference Stop" name="Invoke-CoreApplication.ps1 Tests.Parameter Validation.Should use ErrorActionPreference Stop" time="0.0885" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected regular expression '\$ErrorActionPreference\s*=\s*"Stop"' to match $null, but it did not match.</message>
                      <stack-trace>at $script:ScriptContent | Should -Match '\$ErrorActionPreference\s*=\s*"Stop"', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:83
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:83
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Invoke-CoreApplication.ps1 Tests.Functionality Tests" executed="True" result="Failure" success="False" time="0.6971" asserts="0" description="Invoke-CoreApplication.ps1 Tests.Functionality Tests">
                <results>
                  <test-case description="Should contain Invoke-LabStep usage" name="Invoke-CoreApplication.ps1 Tests.Functionality Tests.Should contain Invoke-LabStep usage" time="0.0884" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected regular expression 'Invoke-LabStep.*-Config.*-Body' to match $null, but it did not match.</message>
                      <stack-trace>at $script:ScriptContent | Should -Match 'Invoke-LabStep.*-Config.*-Body', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:90
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:90
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should contain proper logging statements" name="Invoke-CoreApplication.ps1 Tests.Functionality Tests.Should contain proper logging statements" time="0.0895" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected regular expression 'Write-CustomLog' to match $null, but it did not match.</message>
                      <stack-trace>at $script:ScriptContent | Should -Match 'Write-CustomLog', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:95
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:95
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should handle JSON configuration loading" name="Invoke-CoreApplication.ps1 Tests.Functionality Tests.Should handle JSON configuration loading" time="0.0931" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected regular expression 'ConvertFrom-Json' to match $null, but it did not match.</message>
                      <stack-trace>at $script:ScriptContent | Should -Match 'ConvertFrom-Json', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:100
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:100
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have try-catch error handling" name="Invoke-CoreApplication.ps1 Tests.Functionality Tests.Should have try-catch error handling" time="0.0204" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression 'try\s*\{' to match $null, but it did not match.
[1] Expected regular expression 'catch\s*\{' to match $null, but it did not match.
[2] Expected regular expression 'throw' to match $null, but it did not match.</message>
                      <stack-trace>[0] at $script:ScriptContent | Should -Match 'try\s*\{', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:105
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:105
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $script:ScriptContent | Should -Match 'catch\s*\{', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:106
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:106
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $script:ScriptContent | Should -Match 'throw', C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:107
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Invoke-CoreApplication.Tests.ps1:107
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Invoke-CoreApplication.ps1 Tests.Integration Tests" executed="True" result="Success" success="True" time="0.7208" asserts="0" description="Invoke-CoreApplication.ps1 Tests.Integration Tests">
                <results>
                  <test-case description="Should validate test config file creation" name="Invoke-CoreApplication.ps1 Tests.Integration Tests.Should validate test config file creation" time="0.0113" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should properly handle valid configuration" name="Invoke-CoreApplication.ps1 Tests.Integration Tests.Should properly handle valid configuration" time="0.0096" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Reset-Git.Tests.ps1" executed="True" result="Success" success="True" time="0.1295" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Reset-Git.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Reset-Git Tests" executed="True" result="Success" success="True" time="0.09" asserts="0" description="Reset-Git Tests">
            <results>
              <test-suite type="TestFixture" name="Reset-Git Tests.Module Loading" executed="True" result="Success" success="True" time="0.0038" asserts="0" description="Reset-Git Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Reset-Git Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Reset-Git Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0077" asserts="0" description="Reset-Git Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Reset-Git Tests.Functionality Tests.should execute without errors" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Reset-Machine.Tests.ps1" executed="True" result="Success" success="True" time="0.1328" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Reset-Machine.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Reset-Machine Tests" executed="True" result="Success" success="True" time="0.091" asserts="0" description="Reset-Machine Tests">
            <results>
              <test-suite type="TestFixture" name="Reset-Machine Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="Reset-Machine Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Reset-Machine Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Reset-Machine Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="Reset-Machine Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Reset-Machine Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Set-LabProfile.Tests.ps1" executed="True" result="Success" success="True" time="0.1214" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Set-LabProfile.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Set-LabProfile Tests" executed="True" result="Success" success="True" time="0.083" asserts="0" description="Set-LabProfile Tests">
            <results>
              <test-suite type="TestFixture" name="Set-LabProfile Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="Set-LabProfile Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Set-LabProfile Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Set-LabProfile Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.01" asserts="0" description="Set-LabProfile Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Set-LabProfile Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Setup-Directories.Tests.ps1" executed="True" result="Success" success="True" time="0.116" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\Setup-Directories.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Setup-Directories Tests" executed="True" result="Success" success="True" time="0.0783" asserts="0" description="Setup-Directories Tests">
            <results>
              <test-suite type="TestFixture" name="Setup-Directories Tests.Module Loading" executed="True" result="Success" success="True" time="0.0038" asserts="0" description="Setup-Directories Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Setup-Directories Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Setup-Directories Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="Setup-Directories Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Setup-Directories Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\setup-test-env.Tests.ps1" executed="True" result="Success" success="True" time="0.1215" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\unit\scripts\setup-test-env.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="setup-test-env Tests" executed="True" result="Success" success="True" time="0.08" asserts="0" description="setup-test-env Tests">
            <results>
              <test-suite type="TestFixture" name="setup-test-env Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="setup-test-env Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="setup-test-env Tests.Module Loading.should load required modules" time="0.0013" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="setup-test-env Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="setup-test-env Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="setup-test-env Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\BadRunnerScripts.Simple.Tests.ps1" executed="True" result="Success" success="True" time="0.1297" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\BadRunnerScripts.Simple.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="BadRunnerScripts.Simple Tests" executed="True" result="Success" success="True" time="0.0892" asserts="0" description="BadRunnerScripts.Simple Tests">
            <results>
              <test-suite type="TestFixture" name="BadRunnerScripts.Simple Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="BadRunnerScripts.Simple Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="BadRunnerScripts.Simple Tests.Module Loading.should load required modules" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BadRunnerScripts.Simple Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.007" asserts="0" description="BadRunnerScripts.Simple Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="BadRunnerScripts.Simple Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\BadRunnerScripts.Tests.ps1" executed="True" result="Success" success="True" time="0.1431" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\BadRunnerScripts.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="BadRunnerScripts Tests" executed="True" result="Success" success="True" time="0.1012" asserts="0" description="BadRunnerScripts Tests">
            <results>
              <test-suite type="TestFixture" name="BadRunnerScripts Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="BadRunnerScripts Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="BadRunnerScripts Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="BadRunnerScripts Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="BadRunnerScripts Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="BadRunnerScripts Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Cleanup-Files.Tests.ps1" executed="True" result="Success" success="True" time="0.1163" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Cleanup-Files.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Cleanup-Files Tests" executed="True" result="Success" success="True" time="0.0762" asserts="0" description="Cleanup-Files Tests">
            <results>
              <test-suite type="TestFixture" name="Cleanup-Files Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="Cleanup-Files Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Cleanup-Files Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Cleanup-Files Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="Cleanup-Files Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Cleanup-Files Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Config-DNS.Tests.ps1" executed="True" result="Success" success="True" time="0.1161" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Config-DNS.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Config-DNS Tests" executed="True" result="Success" success="True" time="0.0787" asserts="0" description="Config-DNS Tests">
            <results>
              <test-suite type="TestFixture" name="Config-DNS Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="Config-DNS Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Config-DNS Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Config-DNS Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0066" asserts="0" description="Config-DNS Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Config-DNS Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1" executed="True" result="Failure" success="False" time="1.015" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="CoreApp Module Tests" executed="True" result="Failure" success="False" time="0.1052" asserts="0" description="CoreApp Module Tests">
            <results>
              <test-suite type="TestFixture" name="CoreApp Module Tests.Module Structure Validation" executed="True" result="Success" success="True" time="0.0723" asserts="0" description="CoreApp Module Tests.Module Structure Validation">
                <results>
                  <test-case description="should have valid module manifest" name="CoreApp Module Tests.Module Structure Validation.should have valid module manifest" time="0.0609" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have module implementation file" name="CoreApp Module Tests.Module Structure Validation.should have module implementation file" time="0.003" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have default configuration file" name="CoreApp Module Tests.Module Structure Validation.should have default configuration file" time="0.0024" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should have scripts directory with core scripts" name="CoreApp Module Tests.Module Structure Validation.should have scripts directory with core scripts" time="0.0037" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="CoreApp Module Tests.Module Import and Loading" executed="True" result="Failure" success="False" time="0.1028" asserts="0" description="CoreApp Module Tests.Module Import and Loading">
                <results>
                  <test-case description="should import CoreApp module successfully" name="CoreApp Module Tests.Module Import and Loading.should import CoreApp module successfully" time="0.0071" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should export Invoke-CoreApplication function" name="CoreApp Module Tests.Module Import and Loading.should export Invoke-CoreApplication function" time="0.0195" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected a value, but got $null or empty.</message>
                      <stack-trace>at Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:101
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:101
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="should have proper environment variable support" name="CoreApp Module Tests.Module Import and Loading.should have proper environment variable support" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Application Scripts Tests" executed="True" result="Failure" success="False" time="0.3904" asserts="0" description="Core Application Scripts Tests">
            <results>
              <test-suite type="TestFixture" name="Core Application Scripts Tests.Script Syntax and Structure Validation" executed="True" result="Failure" success="False" time="0.1527" asserts="0" description="Core Application Scripts Tests.Script Syntax and Structure Validation">
                <results>
                  <test-case description="should have valid PowerShell syntax for all core scripts" name="Core Application Scripts Tests.Script Syntax and Structure Validation.should have valid PowerShell syntax for all core scripts" time="0.0408" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected 0, because Script 0100_Enable-WinRM.ps1 should have valid syntax, but got 2.
[1] Expected 0, because Script 0101_Enable-RemoteDesktop.ps1 should have valid syntax, but got 1.
[2] Expected 0, because Script 0104_Install-CA.ps1 should have valid syntax, but got 2.
[3] Expected 0, because Script 0106_Install-WAC.ps1 should have valid syntax, but got 1.
[4] Expected 0, because Script 0202_Install-NodeGlobalPackages.ps1 should have valid syntax, but got 1.</message>
                      <stack-trace>[0] at $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[4] at $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:123
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="should follow PowerShell 7.0+ requirements" name="Core Application Scripts Tests.Script Syntax and Structure Validation.should follow PowerShell 7.0+ requirements" time="0.0271" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should use proper error handling patterns" name="Core Application Scripts Tests.Script Syntax and Structure Validation.should use proper error handling patterns" time="0.0823" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    # Check if WinRM is already configured
    $winrmStatus = Get-Service -Name WinRM -ErrorAction SilentlyContinue
    if ($winrmStatus -and $winrmStatus.Status -eq 'Running') {
        Write-CustomLog 'WinRM is already enabled and running.'
    } else {
        Write-CustomLog 'Enabling WinRM via Enable-PSRemoting -Force'
        # WinRM QuickConfig
        Enable-PSRemoting -Force
        Write-CustomLog 'Enable-PSRemoting executed'
        # Optionally configure additional authentication methods, etc.:
        # e.g.: Set-Item -Path WSMan:\localhost\Service\Auth\Basic -Value $true
    }
}
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
', because 0100_Enable-WinRM.ps1 should use try-catch error handling, but it did not match.
[1] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    # Check current Remote Desktop status
    $currentStatus = Get-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections'
    if ($Config.AllowRemoteDesktop -eq $true) {
        if ($currentStatus.fDenyTSConnections -eq 0) {
            Write-CustomLog "Remote Desktop is already enabled."
        }
        else {
            Write-CustomLog "Enabling Remote Desktop via Set-ItemProperty"
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                             -Name 'fDenyTSConnections' `
                             -Value 0
            Write-CustomLog "Remote Desktop enabled"
        }
    }
    else {
        if ($currentStatus.fDenyTSConnections -ne 1) {
            Write-CustomLog "Disabling Remote Desktop via Set-ItemProperty"
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                             -Name 'fDenyTSConnections' `
                             -Value 1
            Write-CustomLog "Remote Desktop disabled"
        }
        else {
            Write-CustomLog "Remote Desktop is already disabled."
        }
    }
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0101_Enable-RemoteDesktop.ps1 should use try-catch error handling, but it did not match.
[2] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    Write-CustomLog "Configuring Firewall rules..."
    if ($null -ne $Config.FirewallPorts) {
        foreach ($port in $Config.FirewallPorts) {
            Write-CustomLog " - Opening TCP port $port"
            New-NetFirewallRule -DisplayName "Open Port $port" `
                                -Direction Inbound `
                                -Protocol TCP `
                                -LocalPort $port `
                                -Action Allow | Out-Null
        }
    } else {
        Write-CustomLog 'No FirewallPorts specified. Skipping.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0102_Configure-Firewall.ps1 should use try-catch error handling, but it did not match.
[3] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
if ($Config.InstallCA -eq $true) {
Write-CustomLog "Checking for existing Certificate Authority (Standalone Root CA)..."
# Only proceed if you actually want to install a CA.
if ($null -eq $Config.CertificateAuthority) {
    Write-CustomLog "No CA config found. Skipping CA installation."
    return
}
$CAName        = $Config.CertificateAuthority.CommonName
$ValidityYears = $Config.CertificateAuthority.ValidityYears
$rol        Write-CustomLog "A Certificate Authority is already configured. Skipping installation."
        return
    }
    Write-CustomLog "CA role is installed but no CA is configured. Proceeding with installation."
} else {
    Write-CustomLog "Installing Certificate Authority role..."
    if ($PSCmdlet.ShouldProcess('ADCS role', 'Install CA Windows feature')) {
        Install-WindowsFeature Adcs-Cert-Authority -IncludeManagementTools -ErrorAction Stop
    }
}
# If the script reaches this point, it means no existing CA is detected, and installation should proceed.
Write-CustomLog "Configuring CA: $CAName with $($ValidityYears) year validity..."
if ($PSCmdlet.ShouldProcess($CAName, 'Configure Standalone Root CA')) {
    # Resolve the cmdlet after any Pester mocks have been defined
    $installCmd = Get-Command Install-AdcsCertificationAuthority -ErrorAction SilentlyContinue
    if (-not $installCmd) {
        if (Get-Module -ListAvailable -Name ADCSDeployment) {
            $installCmd = Get-Command Install-AdcsCertificationAuthority -ErrorAction SilentlyContinue
        }
    }
    if (-not $installCmd) {
        Write-CustomLog 'Install-AdcsCertificationAuthority command not found. Ensure AD CS features are available.'
        return
    }
    &amp; $installCmd `
        -CAType StandaloneRootCA `
        -CACommonName $CAName `
        -KeyLength 2048 `
        -HashAlgorithm SHA256 `
        -ValidityPeriod Years `
        -ValidityPeriodUnits $ValidityYears `
        -Force
}
', because 0104_Install-CA.ps1 should use try-catch error handling, but it did not match.
[4] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
function Get-WacRegistryInstallation {
    [CmdletBinding()
    param(
        [Parameter(Mandatory)]
        [string]$RegistryPath
    )
    
    $items = Get-ChildItem $RegistryPath -ErrorAction SilentlyContinue
    foreach ($item in $items) {
        $itemProps = Get-ItemProperty $item.PSPath -ErrorAction SilentlyContinue
        if ($itemProps.PSObject.Properties['DisplayName'] -and $itemProps.DisplayName -like "*Windows Admin Center*") {
            return $itemProps
        }
    }
    return $null
}
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallWAC -eq $true) {
        $WacConfig = $Config.WindowsAdminCenter
        if (-not $WacConfig) {
            Write-CustomLog 'No Windows Admin Center configuration found. Skipping installation.'
            return
        }
        
        $installPort = if ($WacConfig.InstallPort) { $WacConfig.InstallPort } else { 443 }
        # Check both standard and Wow6432Node uninstall registry keys for WAC installation
        $wacInstalled = Get-WacRegistryInstallation -RegistryPath "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
        if (-not $wacInstalled) {
            $wacInstalled = Get-WacRegistryInstallation -RegistryPath "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
        }
        if ($wacInstalled) {
            Write-CustomLog "Windows Admin Center is already installed. Skipping installation."
            return
        }
        # Check if the desired installation port is already in use
        $portInUse = Get-NetTCPConnection -LocalPort $installPort -ErrorAction SilentlyContinue
        if ($portInUse) {
            Write-CustomLog "Port $installPort is already in use. Assuming Windows Admin Center is running. Skipping installation."
            return
        }
        Write-CustomLog "Installing Windows Admin Center..."
        
        $url = if ($WacConfig.InstallerUrl) { 
            $WacConfig.InstallerUrl 
        } else { 
            'https://aka.ms/WACDownload' 
        }
        
        Invoke-LabDownload -Uri $url -Prefix 'wac-installer' -Extension '.msi' -Action {
            param($installerPath)
            
            Write-CustomLog "Installing WAC silently on port $installPort"
            if ($PSCmdlet.ShouldProcess($installerPath, 'Install Windows Admin Center')) {
                $logPath = Join-Path (Get-CrossPlatformTempPath) 'WacInstall.log'
                Start-Process msiexec.exe -Wait -ArgumentList "/i `"$installerPath`" /qn /L*v `"$logPath`" SME_PORT=$installPort ACCEPT_EULA=1"
            }
            Write-CustomLog "WAC installation complete."
        }
    } else {
        Write-CustomLog 'InstallWAC flag is disabled. Skipping installation.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0106_Install-WAC.ps1 should use try-catch error handling, but it did not match.
[5] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if ($Config.DisableTCPIP6 -eq $true) {
        if (Get-Platform -eq 'Windows') {
            Write-CustomLog 'Disabling IPv6 bindings on all adapters'
            
            if ($PSCmdlet.ShouldProcess('IPv6 bindings', 'Disable on all adapters')) {
                Get-NetAdapterBinding -ComponentID 'ms_tcpip6' | 
                    Where-Object { $_.Enabled -eq $true } | 
                    Disable-NetAdapterBinding -ComponentID 'ms_tcpip6'
            }
            Write-CustomLog 'IPv6 bindings disabled'
        } else {
            Write-CustomLog 'IPv6 configuration is only supported on Windows platform' -Level 'WARN'
        }
    } else {
        Write-CustomLog 'DisableTCPIP6 flag is disabled. Skipping configuration.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0111_Disable-TCPIP6.ps1 should use try-catch error handling, but it did not match.
[6] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if ($Config.ConfigPXE -eq $true) {
        if (Get-Platform -eq 'Windows') {
            Write-CustomLog "Adding inbound firewall rule 'prov-pxe-67' (UDP 67)"
            if ($PSCmdlet.ShouldProcess('prov-pxe-67', 'Create firewall rule')) {
                New-NetFirewallRule -DisplayName prov-pxe-67 -Enabled True -Direction inbound -Protocol udp -LocalPort 67 -Action Allow -RemoteAddress any
            }
            
            Write-CustomLog "Adding inbound firewall rule 'prov-pxe-69' (UDP 69)"
            if ($PSCmdlet.ShouldProcess('prov-pxe-69', 'Create firewall rule')) {
                New-NetFirewallRule -DisplayName prov-pxe-69 -Enabled True -Direction inbound -Protocol udp -LocalPort 69 -Action Allow -RemoteAddress any
            }
            
            Write-CustomLog "Adding inbound firewall rule 'prov-pxe-17519' (TCP 17519)"
            if ($PSCmdlet.ShouldProcess('prov-pxe-17519', 'Create firewall rule')) {
                New-NetFirewallRule -DisplayName prov-pxe-17519 -Enabled True -Direction inbound -Protocol tcp -LocalPort 17519 -Action Allow -RemoteAddress any
            }
            
            Write-CustomLog "Adding inbound firewall rule 'prov-pxe-17530' (TCP 17530)"
            if ($PSCmdlet.ShouldProcess('prov-pxe-17530', 'Create firewall rule')) {
                New-NetFirewallRule -DisplayName prov-pxe-17530 -Enabled True -Direction inbound -Protocol tcp -LocalPort 17530 -Action Allow -RemoteAddress any
            }
            
            Write-CustomLog 'PXE firewall rules configured'
        } else {
            Write-CustomLog 'PXE configuration is only supported on Windows platform' -Level 'WARN'
        }
    } else {
        Write-CustomLog 'ConfigPXE flag is disabled. Skipping configuration.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0112_Enable-PXE.ps1 should use try-catch error handling, but it did not match.
[7] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if ($Config.SetTrustedHosts -eq $true) {
        $trustedHosts = if ($Config.TrustedHosts) { $Config.TrustedHosts } else { '*' }
        $args = "/d /c winrm set winrm/config/client @{TrustedHosts=`"$trustedHosts`"}"
        Write-CustomLog "Configuring TrustedHosts with: $args"
        
        if ($PSCmdlet.ShouldProcess($trustedHosts, 'Configure WinRM TrustedHosts')) {
            Start-Process -FilePath cmd.exe -ArgumentList $args -Wait
        }
        Write-CustomLog 'TrustedHosts configured'
    } else {
        Write-CustomLog 'SetTrustedHosts flag is disabled. Skipping configuration.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0114_Config-TrustedHosts.ps1 should use try-catch error handling, but it did not match.
[8] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if (-not $Config.InstallSysinternals) {
        Write-CustomLog 'InstallSysinternals flag is disabled. Skipping installation.'
        return
    }
    $destDir = if ($Config.SysinternalsPath) { 
        $Config.SysinternalsPath 
    } else { 
        'C:/Sysinternals' 
    }
    
    if (-not (Test-Path $destDir)) {
        Write-CustomLog "Installing Sysinternals to $destDir"
        $url = 'https://download.sysinternals.com/files/SysinternalsSuite.zip'
        
        Invoke-LabDownload -Uri $url -Prefix 'sysinternals' -Extension '.zip' -Action {
            param($zipPath)
            
            if ($PSCmdlet.ShouldProcess($destDir, 'Create Sysinternals directory')) {
                New-Item -ItemType Directory -Path $destDir -Force | Out-Null
            }
            
            Write-CustomLog "Extracting to $destDir"
            if ($PSCmdlet.ShouldProcess($zipPath, 'Extract Sysinternals')) {
                Expand-Archive -Path $zipPath -DestinationPath $destDir -Force
            }
        }
        
        # Add to PATH
        $env:PATH = "$env:PATH;$destDir"
        Write-CustomLog 'Sysinternals installation completed.'
    } else {
        Write-CustomLog "Sysinternals is already installed at $destDir"
    }
    $psInfo = Join-Path $destDir 'PsInfo.exe'
    if (Test-Path $psInfo) {
        Write-CustomLog 'Verifying PsInfo.exe installation'
        Write-CustomLog "PsInfo.exe found at $psInfo"
    } else {
        Write-CustomLog 'PsInfo.exe not found after installation' -Level 'WARN'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0205_Install-Sysinternals.ps1 should use try-catch error handling, but it did not match.
[9] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallPython -eq $true) {
        if (-not (Get-Command python.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Python..."
            $url = 'https://www.python.org/ftp/python/3.12.3/python-3.12.3-amd64.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'python-installer' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install Python')) {
                    Start-Process -FilePath $installer -ArgumentList '/quiet InstallAllUsers=1 PrependPath=1' -Wait
                    
                    # Refresh PATH for the current session
                    $userPath = [Environment]::GetEnvironmentVariable('PATH', 'User')
                    $machinePath = [Environment]::GetEnvironmentVariable('PATH', 'Machine')
                    $env:PATH = (($userPath, $machinePath) -join ';')
                    Write-CustomLog 'PATH refreshed with new Python location.'
                }
            }
            Write-CustomLog "Python installation completed."
        } else {
            Write-CustomLog "Python is already installed."
        }
    } else {
        Write-CustomLog "InstallPython flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0206_Install-Python.ps1 should use try-catch error handling, but it did not match.
[10] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallGit -eq $true) {
        if (-not (Get-Command git.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Git..."
            $url = 'https://github.com/git-for-windows/git/releases/download/v2.48.1.windows.1/Git-2.48.1-64-bit.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'git-installer' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install Git')) {
                    Start-Process -FilePath $installer -ArgumentList '/SILENT' -Wait
                }
            }
            Write-CustomLog "Git installation completed."
        } else {
            Write-CustomLog "Git is already installed."
        }
    } else {
        Write-CustomLog "InstallGit flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0207_Install-Git.ps1 should use try-catch error handling, but it did not match.
[11] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallDockerDesktop -eq $true) {
        if (-not (Get-Command docker.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Docker Desktop..."
            $url = 'https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'docker-desktop-installer' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install Docker Desktop')) {
                    Start-Process -FilePath $installer -ArgumentList 'install --quiet' -Wait
                }
            }
            Write-CustomLog "Docker Desktop installation completed."
        } else {
            Write-CustomLog "Docker Desktop is already installed."
        }
    } else {
        Write-CustomLog "InstallDockerDesktop flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0208_Install-DockerDesktop.ps1 should use try-catch error handling, but it did not match.
[12] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.Install7Zip -eq $true) {
        if (-not (Get-Command 7z.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing 7-Zip..."
            $url = 'https://www.7-zip.org/a/7z2301-x64.exe'
            
            Invoke-LabDownload -Uri $url -Prefix '7zip' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install 7-Zip')) {
                    Start-Process -FilePath $installer -ArgumentList '/S' -Wait
                }
            }
            Write-CustomLog "7-Zip installation completed."
        } else {
            Write-CustomLog "7-Zip is already installed."
        }
    } else {
        Write-CustomLog "Install7Zip flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0209_Install-7Zip.ps1 should use try-catch error handling, but it did not match.
[13] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallVSCode -eq $true) {
        if (-not (Get-Command code.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Visual Studio Code..."
            $url = 'https://update.code.visualstudio.com/latest/win32-x64-user/stable'
            
            Invoke-LabDownload -Uri $url -Prefix 'vscode' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install VS Code')) {
                    Start-Process -FilePath $installer -ArgumentList '/verysilent /suppressmsgboxes /mergetasks=!runcode' -Wait
                }
            }
            Write-CustomLog "Visual Studio Code installation completed."
        } else {
            Write-CustomLog "Visual Studio Code is already installed."
        }
    } else {
        Write-CustomLog "InstallVSCode flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0210_Install-VSCode.ps1 should use try-catch error handling, but it did not match.
[14] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallVSBuildTools -eq $true) {
        if (-not (Test-Path 'C:/BuildTools')) {
            Write-CustomLog "Installing Visual Studio Build Tools..."
            $url = 'https://aka.ms/vs/17/release/vs_BuildTools.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'vs_buildtools' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install VS Build Tools')) {
                    Start-Process -FilePath $installer -ArgumentList '--quiet --wait --norestart --nocache --installPath C:/BuildTools' -Wait
                }
            }
            Write-CustomLog "Visual Studio Build Tools installation completed."
        } else {
            Write-CustomLog "Visual Studio Build Tools are already installed."
        }
    } else {
        Write-CustomLog "InstallVSBuildTools flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0211_Install-VSBuildTools.ps1 should use try-catch error handling, but it did not match.
[15] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallAzureCLI -eq $true) {
        if (-not (Get-Command az.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Azure CLI..."
            $url = 'https://aka.ms/installazurecliwindows'
            
            Invoke-LabDownload -Uri $url -Prefix 'azure-cli' -Extension '.msi' -Action {
                param($msi)
                if ($PSCmdlet.ShouldProcess($msi, 'Install Azure CLI')) {
                    Start-Process msiexec.exe -ArgumentList "/i `"$msi`" /quiet /norestart" -Wait -NoNewWindow
                }
            }
            Write-CustomLog "Azure CLI installation completed."
        } else {
            Write-CustomLog "Azure CLI is already installed."
        }
    } else {
        Write-CustomLog "InstallAzureCLI flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0212_Install-AzureCLI.ps1 should use try-catch error handling, but it did not match.
[16] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallAWSCLI -eq $true) {
        if (-not (Get-Command aws.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing AWS CLI..."
            $url = 'https://awscli.amazonaws.com/AWSCLIV2.msi'
            
            Invoke-LabDownload -Uri $url -Prefix 'awscli' -Extension '.msi' -Action {
                param($msi)
                if ($PSCmdlet.ShouldProcess($msi, 'Install AWS CLI')) {
                    Start-Process msiexec.exe -ArgumentList "/i `"$msi`" /quiet /norestart" -Wait -NoNewWindow
                }
            }
            Write-CustomLog "AWS CLI installation completed."
        } else {
            Write-CustomLog "AWS CLI is already installed."
        }
    } else {
        Write-CustomLog "InstallAWSCLI flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0213_Install-AWSCLI.ps1 should use try-catch error handling, but it did not match.
[17] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallPacker -eq $true) {
        if (-not (Get-Command packer.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Packer..."
            $url = 'https://releases.hashicorp.com/packer/1.9.4/packer_1.9.4_windows_amd64.zip'
            $dest = Join-Path $env:ProgramFiles 'Packer'
            Invoke-LabDownload -Uri $url -Prefix 'packer' -Extension '.zip' -Action {
                param($zip)
                if (-not (Test-Path $dest)) {
                    New-Item -ItemType Directory -Path $dest -Force | Out-Null
                }
                Expand-Archive -Path $zip -DestinationPath $dest -Force
                # Add to PATH
                $env:PATH = "$env:PATH;$dest"
            }
            Write-CustomLog "Packer installation completed."
        } else {
            Write-CustomLog "Packer is already installed."
        }
    } else {
        Write-CustomLog "InstallPacker flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0214_Install-Packer.ps1 should use try-catch error handling, but it did not match.
[18] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallChocolatey -eq $true) {
        if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Chocolatey..."
            $command = "Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))"
            if ($PSCmdlet.ShouldProcess('Chocolatey', 'Install package manager')) {
                Start-Process powershell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -Command $command" -Wait
            }
            Write-CustomLog "Chocolatey installation completed."
        } else {
            Write-CustomLog "Chocolatey is already installed."
        }
    } else {
        Write-CustomLog "InstallChocolatey flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0215_Install-Chocolatey.ps1 should use try-catch error handling, but it did not match.
[19] Expected regular expression 'try\s*\{[\s\S]*?\}\s*catch' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
function Set-LabProfile {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [object]$Config
    )
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if ($Config.SetupLabProfile -eq $true) {
        $profilePath = $PROFILE.CurrentUserAllHosts
        $profileDir = Split-Path $profilePath
        if (-not (Test-Path $profileDir)) {
            if ($PSCmdlet.ShouldProcess($profileDir, 'Create profile directory')) {
                New-Item -ItemType Directory -Path $profileDir -Force | Out-Null
            }
        }
        $repoRoot = Resolve-Path -Path (Join-Path $PSScriptRoot '..')
        $content = @"
# OpenTofu Lab Automation profile
`$env:PATH = "$repoRoot;`$env:PATH"
`$env:PSModulePath = "$repoRoot/core-runner/modules;`$env:PSModulePath"
"@
        if ($PSCmdlet.ShouldProcess($profilePath, 'Create PowerShell profile')) {
            Set-Content -Path $profilePath -Value $content
            Write-CustomLog "PowerShell profile created at $profilePath"
        }
    } else {
        Write-CustomLog "SetupLabProfile flag is disabled. Skipping profile setup."
    }
}
Invoke-LabStep -Config $Config -Body {
    Set-LabProfile -Config $Config
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0216_Set-LabProfile.ps1 should use try-catch error handling, but it did not match.</message>
                      <stack-trace>[0] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[4] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[5] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[6] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[7] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[8] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[9] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[10] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[11] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[12] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[13] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[14] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[15] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[16] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[17] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[18] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[19] at $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:141
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Core Application Scripts Tests.Script Content Analysis" executed="True" result="Failure" success="False" time="0.2811" asserts="0" description="Core Application Scripts Tests.Script Content Analysis">
                <results>
                  <test-case description="should define expected functions in numbered scripts" name="Core Application Scripts Tests.Script Content Analysis.should define expected functions in numbered scripts" time="0.0752" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression 'function\s+Install-ValidationTools' to match '#Requires -Version 7.0
[CmdletBinding()]
param(
    [Parameter()]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
function Install-Cosign {
    [CmdletBinding(SupportsShouldProcess)]
    param()
    
    # Check if cosign is available in the current PATH
    if (-not (Test-Path (Join-Path $Config.CosignPath 'cosign-windows-amd64.exe') -ErrorAction SilentlyContinue)) {
        Write-CustomLog 'Cosign is not found. Installing cosign...' -Level 'INFO'
        
        # Define the installation directory and destination file path
        $installDir = $Config.CosignPath
        $destination = Join-Path $installDir 'cosign-windows-amd64.exe'
        # Create the installation folder if it doesn't exist
        if (-not (Test-Path $installDir)) {
            if ($PSCmdlet.ShouldProcess($installDir, 'Create directory')) {
                New-Item -ItemType Directory -Path $installDir -Force | Out-Null
            }
        }
        if (-not (Test-Path $destination)) {
            try {
                if ($PSCmdlet.ShouldProcess($destination, 'Download cosign')) {
                    # Download the cosign executable
                    Invoke-LabWebRequest -Uri $Config.CosignURL -OutFile $destination -UseBasicParsing
                    Write-CustomLog "Cosign downloaded and installed at $destination" -Level 'INFO'
                }
            } catch {
                Write-Error "Failed to download cosign from $($Config.CosignURL). Please check your internet connection and try again."
                return
            }
        }
        # Add the installation folder to the user's PATH if not already present
        $userPath = [Environment]::GetEnvironmentVariable('PATH', 'User')
        if (-not $userPath) { $userPath = '' }
        if (-not $userPath.Contains($installDir)) {
            if ($PSCmdlet.ShouldProcess('User PATH', 'Update environment variable')) {
                [Environment]::SetEnvironmentVariable('PATH', "$userPath;$installDir", 'User')
                Write-CustomLog "Added $installDir to your user PATH. You may need to restart your session for this change to take effect." -Level 'INFO'
            }
        }
    } else {
        Write-CustomLog 'Cosign is already installed.' -Level 'INFO'
    }
}
function Find-Gpg {
    # Check if gpg is available in the current PATH
    if (-not (Get-Command gpg -ErrorAction SilentlyContinue)) {
        Write-CustomLog 'GPG is not found.' -Level 'WARN'
        Write-CustomLog 'Please install Gpg4win from https://www.gpg4win.org/ and ensure it is added to your PATH.' -Level 'WARN'
    } else {
        Write-CustomLog 'GPG is already installed.' -Level 'INFO'
    }
}
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    # Execute based on provided switches
    if ($Config.InstallCosign -eq $true) {
        Install-Cosign
    } elseif ($Config.InstallGpg -eq $true) {
        Find-Gpg
    }
    if (-not $Config.InstallCosign -and -not $Config.InstallGpg) {
        Write-CustomLog 'No installation option specified. Use -InstallCosign and/or -InstallGpg when running this script.' -Level 'WARN'
    }
    
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0006_Install-ValidationTools.ps1 should define Install-ValidationTools function, but it did not match.
[1] Expected regular expression 'function\s+Install-Go' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
try {
    Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
    Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
    Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
    Invoke-LabStep -Config $Config -Body {
        Write-CustomLog -Level 'INFO' -Message "Running $($MyInvocation.MyCommand.Name)"
        if ($Config.InstallGo -eq $true) {
            $GoConfig = $Config.Go
            if ($null -eq $GoConfig) {
                Write-CustomLog -Level 'WARN' -Message 'No Go configuration found. Skipping installation.'
                return
            }
            if ($GoConfig.InstallerUrl) {
                $installerUrl = $GoConfig.InstallerUrl
                if ($installerUrl -match 'go([\d\.]+)\.windows-([a-z0-9]+)\.msi') {
                    $goVersion = $matches[1]
                    $goArch = $matches[2]
                } else {
                    Write-CustomLog -Level 'ERROR' -Message 'Unable to extract Go version and architecture from InstallerUrl.'
                    return
                }
            } elseif ($GoConfig.Version) {
                $goVersion = $GoConfig.Version
                $goArch = $GoConfig.Architecture
                if (-not $goArch) { $goArch = 'amd64' }
            } else {
                Write-CustomLog -Level 'WARN' -Message 'No Go version or InstallerUrl specified. Skipping installation.'
                return
            }
            # Check if Go is already installed by looking for the 'go' command
            if (Get-Command go -ErrorAction SilentlyContinue) {
                Write-CustomLog -Level 'INFO' -Message 'Go is already installed. Skipping installation.'
                return
            }
            Write-CustomLog -Level 'INFO' -Message "Installing Go version $goVersion for architecture $goArch..."
            $ProgressPreference = 'SilentlyContinue'
            Invoke-LabDownload -Uri $installerUrl -Prefix 'GoInstaller' -Extension '.msi' -Action {
                param($installerPath)
                Write-CustomLog 'Installing Go silently...'
                Start-Process msiexec.exe -Wait -ArgumentList "/i `"$installerPath`" /qn /L*v `"$(Get-CrossPlatformTempPath)\GoInstall.log`""
                Write-CustomLog 'Go installation complete.'
            }
        } else {
            Write-CustomLog -Level 'INFO' -Message 'InstallGo flag is disabled. Skipping Go installation.'
        }
        Write-CustomLog -Level 'INFO' -Message "Completed $($MyInvocation.MyCommand.Name)"
    }
    Write-CustomLog -Level 'INFO' -Message "Completed $($MyInvocation.MyCommand.Name)"
} catch {
    Write-CustomLog -Level 'ERROR' -Message "Go installation failed: $_"
    throw
}
', because 0007_Install-Go.ps1 should define Install-Go function, but it did not match.
[2] Expected regular expression 'function\s+Install-CA' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
if ($Config.InstallCA -eq $true) {
Write-CustomLog "Checking for existing Certificate Authority (Standalone Root CA)..."
# Only proceed if you actually want to install a CA.
if ($null -eq $Config.CertificateAuthority) {
    Write-CustomLog "No CA config found. Skipping CA installation."
    return
}
$CAName        = $Config.CertificateAuthority.CommonName
$ValidityYears = $Config.CertificateAuthority.ValidityYears
$rol        Write-CustomLog "A Certificate Authority is already configured. Skipping installation."
        return
    }
    Write-CustomLog "CA role is installed but no CA is configured. Proceeding with installation."
} else {
    Write-CustomLog "Installing Certificate Authority role..."
    if ($PSCmdlet.ShouldProcess('ADCS role', 'Install CA Windows feature')) {
        Install-WindowsFeature Adcs-Cert-Authority -IncludeManagementTools -ErrorAction Stop
    }
}
# If the script reaches this point, it means no existing CA is detected, and installation should proceed.
Write-CustomLog "Configuring CA: $CAName with $($ValidityYears) year validity..."
if ($PSCmdlet.ShouldProcess($CAName, 'Configure Standalone Root CA')) {
    # Resolve the cmdlet after any Pester mocks have been defined
    $installCmd = Get-Command Install-AdcsCertificationAuthority -ErrorAction SilentlyContinue
    if (-not $installCmd) {
        if (Get-Module -ListAvailable -Name ADCSDeployment) {
            $installCmd = Get-Command Install-AdcsCertificationAuthority -ErrorAction SilentlyContinue
        }
    }
    if (-not $installCmd) {
        Write-CustomLog 'Install-AdcsCertificationAuthority command not found. Ensure AD CS features are available.'
        return
    }
    &amp; $installCmd `
        -CAType StandaloneRootCA `
        -CACommonName $CAName `
        -KeyLength 2048 `
        -HashAlgorithm SHA256 `
        -ValidityPeriod Years `
        -ValidityPeriodUnits $ValidityYears `
        -Force
}
', because 0104_Install-CA.ps1 should define Install-CA function, but it did not match.
[3] Expected regular expression 'function\s+Install-HyperV' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if ($Config.InstallHyperV -eq $true) {
        Write-CustomLog "Checking if Hyper-V is already installed..."
        # Get the installation state of Hyper-V
        $feature = Get-WindowsFeature -Name Hyper-V
        if ($feature -and $feature.Installed) {
            Write-CustomLog "Hyper-V is already installed. Skipping installation."
            return
        }
        Write-CustomLog "Hyper-V is not installed. Proceeding with installation..."
        $enableMgtTools = $true
        if ($Config.PSObject.Properties.Name -contains 'HyperV' -and
            $Config.HyperV.PSObject.Properties.Name -contains 'EnableManagementTools') {
            $enableMgtTools = [bool]$Config.HyperV.EnableManagementTools
        }
        $restart = $false  # Change to $true if you want an automatic restart
        try {
            if ($restart) {
                Install-WindowsFeature -Name 'Hyper-V' -IncludeManagementTools:$enableMgtTools -Restart -ErrorAction Continue
            } else {
                Install-WindowsFeature -Name 'Hyper-V' -IncludeManagementTools:$enableMgtTools -ErrorAction Continue
            }
        } catch {
        
            Write-CustomLog "Only works on Windows Server. Error details: $($_.Exception.Message)"
        }
        Write-CustomLog 'Hyper-V installation complete. A restart is typically required to finalize installation.'
    } else {
        Write-CustomLog 'InstallHyperV flag is disabled. Skipping Hyper-V installation.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0105_Install-HyperV.ps1 should define Install-HyperV function, but it did not match.
[4] Expected regular expression 'function\s+Install-WAC' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
function Get-WacRegistryInstallation {
    [CmdletBinding()
    param(
        [Parameter(Mandatory)]
        [string]$RegistryPath
    )
    
    $items = Get-ChildItem $RegistryPath -ErrorAction SilentlyContinue
    foreach ($item in $items) {
        $itemProps = Get-ItemProperty $item.PSPath -ErrorAction SilentlyContinue
        if ($itemProps.PSObject.Properties['DisplayName'] -and $itemProps.DisplayName -like "*Windows Admin Center*") {
            return $itemProps
        }
    }
    return $null
}
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallWAC -eq $true) {
        $WacConfig = $Config.WindowsAdminCenter
        if (-not $WacConfig) {
            Write-CustomLog 'No Windows Admin Center configuration found. Skipping installation.'
            return
        }
        
        $installPort = if ($WacConfig.InstallPort) { $WacConfig.InstallPort } else { 443 }
        # Check both standard and Wow6432Node uninstall registry keys for WAC installation
        $wacInstalled = Get-WacRegistryInstallation -RegistryPath "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
        if (-not $wacInstalled) {
            $wacInstalled = Get-WacRegistryInstallation -RegistryPath "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
        }
        if ($wacInstalled) {
            Write-CustomLog "Windows Admin Center is already installed. Skipping installation."
            return
        }
        # Check if the desired installation port is already in use
        $portInUse = Get-NetTCPConnection -LocalPort $installPort -ErrorAction SilentlyContinue
        if ($portInUse) {
            Write-CustomLog "Port $installPort is already in use. Assuming Windows Admin Center is running. Skipping installation."
            return
        }
        Write-CustomLog "Installing Windows Admin Center..."
        
        $url = if ($WacConfig.InstallerUrl) { 
            $WacConfig.InstallerUrl 
        } else { 
            'https://aka.ms/WACDownload' 
        }
        
        Invoke-LabDownload -Uri $url -Prefix 'wac-installer' -Extension '.msi' -Action {
            param($installerPath)
            
            Write-CustomLog "Installing WAC silently on port $installPort"
            if ($PSCmdlet.ShouldProcess($installerPath, 'Install Windows Admin Center')) {
                $logPath = Join-Path (Get-CrossPlatformTempPath) 'WacInstall.log'
                Start-Process msiexec.exe -Wait -ArgumentList "/i `"$installerPath`" /qn /L*v `"$logPath`" SME_PORT=$installPort ACCEPT_EULA=1"
            }
            Write-CustomLog "WAC installation complete."
        }
    } else {
        Write-CustomLog 'InstallWAC flag is disabled. Skipping installation.'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0106_Install-WAC.ps1 should define Install-WAC function, but it did not match.
[5] Expected regular expression 'function\s+Install-NodeCore' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    Write-CustomLog "Installing Node.js Core"
    $nodeDeps = if ($Config -is [hashtable]) { 
        $Config.Node_Dependencies 
    } else { 
        $Config.Node_Dependencies 
    }
    
    if (-not $nodeDeps) {
        Write-CustomLog "Config missing Node_Dependencies; skipping Node.js installation."
        return
    }
    if ($nodeDeps.InstallNode) {
        if (Get-Command node -ErrorAction SilentlyContinue) {
            Write-CustomLog "Node.js already installed. Skipping installation."
            return
        }
        
        try {
            $url = $null
            if ($nodeDeps.Node) {
                if ($nodeDeps.Node -is [hashtable]) {
                    $url = $nodeDeps.Node.InstallerUrl
                } else {
                    $url = $nodeDeps.Node.InstallerUrl
                }
            }
            
            if (-not $url) {
                # Use default Node.js LTS installer URL
                $url = 'https://nodejs.org/dist/v20.11.0/node-v20.11.0-x64.msi'
                Write-CustomLog "Using default Node.js installer URL: $url"
            }
            
            Write-CustomLog "Installing Node.js from: $url"
            
            Invoke-LabDownload -Uri $url -Prefix 'node-installer' -Extension '.msi' -Action {
                param($installer)
                
                if ($PSCmdlet.ShouldProcess($installer, 'Install Node.js')) {
                    Start-Process msiexec.exe -ArgumentList "/i `"$installer`" /quiet /norestart" -Wait -NoNewWindow
                }
            }
            
            Write-CustomLog "Node.js installation completed."
        } catch {
            Write-CustomLog "Node.js installation failed: $_" -Level 'ERROR'
            throw
        }
    } else {
        Write-CustomLog "InstallNode flag is disabled. Skipping Node.js installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0201_Install-NodeCore.ps1 should define Install-NodeCore function, but it did not match.
[6] Expected regular expression 'function\s+Install-NodeGlobalPackages' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
function Install-GlobalPackage {
    &lt;#
    .SYNOPSIS
        Installs a global npm package
    
    .PARAMETER Package
        The npm package name to install
    #&gt;
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [string]$Package
    )
    if (Get-Command npm -ErrorAction SilentlyContinue) {
        Write-CustomLog "Installing npm package: $Package..."
        if ($PSCmdlet.ShouldProcess($Package, 'Install npm package')) {
            npm install -g $Package
        }
    } else {
        Write-CustomLog 'npm is not available. Node.js may not have installed correctly.' -Level 'ERROR'
        throw 'npm command not found'
    }
}
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    $nodeDeps = $Config.Node_Dependencies
    if (-not $nodeDeps) {
        Write-CustomLog 'Node_Dependencies configuration not found. Skipping global package installation.'
        return
    }
    $packages = @()
    
    # Parse configuration for packages to install
    if ($nodeDeps -is [hashtable]) {
        if ($nodeDeps.ContainsKey('InstallYarn') -and $nodeDeps.InstallYarn) { 
            $packages += 'yarn' 
        }
        if ($nodeDeps.ContainsKey('InstallVite') -and $nodeDeps.InstallVite) { 
            $packages += 'vite' 
        }
        if ($nodeDeps.ContainsKey('InstallNodemon') -and $nodeDeps.InstallNodemon) { 
            $packages += 'nodemon' 
        }
    } else {
        if ($nodeDeps.PSObject.Properties.Match('InstallYarn').Count -and $nodeDeps.InstallYarn) {
            $packages += 'yarn'
        }
        if ($nodeDeps.PSObject.Properties.Match('InstallVite').Count -and $nodeDeps.InstallVite) {
            $packages += 'vite'
        }
        if ($nodeDeps.PSObject.Properties.Match('InstallNodemon').Count -and $nodeDeps.InstallNodemon) {
            $packages += 'nodemon'
        }
    }
    if (-not $packages) {
        Write-CustomLog 'No global npm packages specified for installation.'
        return
    }
    Write-CustomLog "Installing global npm packages: $($packages -join ', ')"
    
    foreach ($package in $packages) {
        try {
            Install-GlobalPackage -Package $package
            Write-CustomLog "Successfully installed $package"
        } catch {
            Write-CustomLog "Failed to install $package: $_" -Level 'ERROR'
        }
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0202_Install-NodeGlobalPackages.ps1 should define Install-NodeGlobalPackages function, but it did not match.
[7] Expected regular expression 'function\s+Install-Sysinternals' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    if (-not $Config.InstallSysinternals) {
        Write-CustomLog 'InstallSysinternals flag is disabled. Skipping installation.'
        return
    }
    $destDir = if ($Config.SysinternalsPath) { 
        $Config.SysinternalsPath 
    } else { 
        'C:/Sysinternals' 
    }
    
    if (-not (Test-Path $destDir)) {
        Write-CustomLog "Installing Sysinternals to $destDir"
        $url = 'https://download.sysinternals.com/files/SysinternalsSuite.zip'
        
        Invoke-LabDownload -Uri $url -Prefix 'sysinternals' -Extension '.zip' -Action {
            param($zipPath)
            
            if ($PSCmdlet.ShouldProcess($destDir, 'Create Sysinternals directory')) {
                New-Item -ItemType Directory -Path $destDir -Force | Out-Null
            }
            
            Write-CustomLog "Extracting to $destDir"
            if ($PSCmdlet.ShouldProcess($zipPath, 'Extract Sysinternals')) {
                Expand-Archive -Path $zipPath -DestinationPath $destDir -Force
            }
        }
        
        # Add to PATH
        $env:PATH = "$env:PATH;$destDir"
        Write-CustomLog 'Sysinternals installation completed.'
    } else {
        Write-CustomLog "Sysinternals is already installed at $destDir"
    }
    $psInfo = Join-Path $destDir 'PsInfo.exe'
    if (Test-Path $psInfo) {
        Write-CustomLog 'Verifying PsInfo.exe installation'
        Write-CustomLog "PsInfo.exe found at $psInfo"
    } else {
        Write-CustomLog 'PsInfo.exe not found after installation' -Level 'WARN'
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0205_Install-Sysinternals.ps1 should define Install-Sysinternals function, but it did not match.
[8] Expected regular expression 'function\s+Install-Python' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallPython -eq $true) {
        if (-not (Get-Command python.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Python..."
            $url = 'https://www.python.org/ftp/python/3.12.3/python-3.12.3-amd64.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'python-installer' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install Python')) {
                    Start-Process -FilePath $installer -ArgumentList '/quiet InstallAllUsers=1 PrependPath=1' -Wait
                    
                    # Refresh PATH for the current session
                    $userPath = [Environment]::GetEnvironmentVariable('PATH', 'User')
                    $machinePath = [Environment]::GetEnvironmentVariable('PATH', 'Machine')
                    $env:PATH = (($userPath, $machinePath) -join ';')
                    Write-CustomLog 'PATH refreshed with new Python location.'
                }
            }
            Write-CustomLog "Python installation completed."
        } else {
            Write-CustomLog "Python is already installed."
        }
    } else {
        Write-CustomLog "InstallPython flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0206_Install-Python.ps1 should define Install-Python function, but it did not match.
[9] Expected regular expression 'function\s+Install-Git' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallGit -eq $true) {
        if (-not (Get-Command git.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Git..."
            $url = 'https://github.com/git-for-windows/git/releases/download/v2.48.1.windows.1/Git-2.48.1-64-bit.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'git-installer' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install Git')) {
                    Start-Process -FilePath $installer -ArgumentList '/SILENT' -Wait
                }
            }
            Write-CustomLog "Git installation completed."
        } else {
            Write-CustomLog "Git is already installed."
        }
    } else {
        Write-CustomLog "InstallGit flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0207_Install-Git.ps1 should define Install-Git function, but it did not match.
[10] Expected regular expression 'function\s+Install-DockerDesktop' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallDockerDesktop -eq $true) {
        if (-not (Get-Command docker.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Docker Desktop..."
            $url = 'https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'docker-desktop-installer' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install Docker Desktop')) {
                    Start-Process -FilePath $installer -ArgumentList 'install --quiet' -Wait
                }
            }
            Write-CustomLog "Docker Desktop installation completed."
        } else {
            Write-CustomLog "Docker Desktop is already installed."
        }
    } else {
        Write-CustomLog "InstallDockerDesktop flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0208_Install-DockerDesktop.ps1 should define Install-DockerDesktop function, but it did not match.
[11] Expected regular expression 'function\s+Install-7Zip' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.Install7Zip -eq $true) {
        if (-not (Get-Command 7z.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing 7-Zip..."
            $url = 'https://www.7-zip.org/a/7z2301-x64.exe'
            
            Invoke-LabDownload -Uri $url -Prefix '7zip' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install 7-Zip')) {
                    Start-Process -FilePath $installer -ArgumentList '/S' -Wait
                }
            }
            Write-CustomLog "7-Zip installation completed."
        } else {
            Write-CustomLog "7-Zip is already installed."
        }
    } else {
        Write-CustomLog "Install7Zip flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0209_Install-7Zip.ps1 should define Install-7Zip function, but it did not match.
[12] Expected regular expression 'function\s+Install-VSCode' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallVSCode -eq $true) {
        if (-not (Get-Command code.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Visual Studio Code..."
            $url = 'https://update.code.visualstudio.com/latest/win32-x64-user/stable'
            
            Invoke-LabDownload -Uri $url -Prefix 'vscode' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install VS Code')) {
                    Start-Process -FilePath $installer -ArgumentList '/verysilent /suppressmsgboxes /mergetasks=!runcode' -Wait
                }
            }
            Write-CustomLog "Visual Studio Code installation completed."
        } else {
            Write-CustomLog "Visual Studio Code is already installed."
        }
    } else {
        Write-CustomLog "InstallVSCode flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0210_Install-VSCode.ps1 should define Install-VSCode function, but it did not match.
[13] Expected regular expression 'function\s+Install-VSBuildTools' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallVSBuildTools -eq $true) {
        if (-not (Test-Path 'C:/BuildTools')) {
            Write-CustomLog "Installing Visual Studio Build Tools..."
            $url = 'https://aka.ms/vs/17/release/vs_BuildTools.exe'
            
            Invoke-LabDownload -Uri $url -Prefix 'vs_buildtools' -Extension '.exe' -Action {
                param($installer)
                if ($PSCmdlet.ShouldProcess($installer, 'Install VS Build Tools')) {
                    Start-Process -FilePath $installer -ArgumentList '--quiet --wait --norestart --nocache --installPath C:/BuildTools' -Wait
                }
            }
            Write-CustomLog "Visual Studio Build Tools installation completed."
        } else {
            Write-CustomLog "Visual Studio Build Tools are already installed."
        }
    } else {
        Write-CustomLog "InstallVSBuildTools flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0211_Install-VSBuildTools.ps1 should define Install-VSBuildTools function, but it did not match.
[14] Expected regular expression 'function\s+Install-AzureCLI' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallAzureCLI -eq $true) {
        if (-not (Get-Command az.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Azure CLI..."
            $url = 'https://aka.ms/installazurecliwindows'
            
            Invoke-LabDownload -Uri $url -Prefix 'azure-cli' -Extension '.msi' -Action {
                param($msi)
                if ($PSCmdlet.ShouldProcess($msi, 'Install Azure CLI')) {
                    Start-Process msiexec.exe -ArgumentList "/i `"$msi`" /quiet /norestart" -Wait -NoNewWindow
                }
            }
            Write-CustomLog "Azure CLI installation completed."
        } else {
            Write-CustomLog "Azure CLI is already installed."
        }
    } else {
        Write-CustomLog "InstallAzureCLI flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0212_Install-AzureCLI.ps1 should define Install-AzureCLI function, but it did not match.
[15] Expected regular expression 'function\s+Install-AWSCLI' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallAWSCLI -eq $true) {
        if (-not (Get-Command aws.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing AWS CLI..."
            $url = 'https://awscli.amazonaws.com/AWSCLIV2.msi'
            
            Invoke-LabDownload -Uri $url -Prefix 'awscli' -Extension '.msi' -Action {
                param($msi)
                if ($PSCmdlet.ShouldProcess($msi, 'Install AWS CLI')) {
                    Start-Process msiexec.exe -ArgumentList "/i `"$msi`" /quiet /norestart" -Wait -NoNewWindow
                }
            }
            Write-CustomLog "AWS CLI installation completed."
        } else {
            Write-CustomLog "AWS CLI is already installed."
        }
    } else {
        Write-CustomLog "InstallAWSCLI flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0213_Install-AWSCLI.ps1 should define Install-AWSCLI function, but it did not match.
[16] Expected regular expression 'function\s+Install-Packer' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallPacker -eq $true) {
        if (-not (Get-Command packer.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Packer..."
            $url = 'https://releases.hashicorp.com/packer/1.9.4/packer_1.9.4_windows_amd64.zip'
            $dest = Join-Path $env:ProgramFiles 'Packer'
            Invoke-LabDownload -Uri $url -Prefix 'packer' -Extension '.zip' -Action {
                param($zip)
                if (-not (Test-Path $dest)) {
                    New-Item -ItemType Directory -Path $dest -Force | Out-Null
                }
                Expand-Archive -Path $zip -DestinationPath $dest -Force
                # Add to PATH
                $env:PATH = "$env:PATH;$dest"
            }
            Write-CustomLog "Packer installation completed."
        } else {
            Write-CustomLog "Packer is already installed."
        }
    } else {
        Write-CustomLog "InstallPacker flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0214_Install-Packer.ps1 should define Install-Packer function, but it did not match.
[17] Expected regular expression 'function\s+Install-Chocolatey' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    
    if ($Config.InstallChocolatey -eq $true) {
        if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
            Write-CustomLog "Installing Chocolatey..."
            $command = "Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))"
            if ($PSCmdlet.ShouldProcess('Chocolatey', 'Install package manager')) {
                Start-Process powershell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -Command $command" -Wait
            }
            Write-CustomLog "Chocolatey installation completed."
        } else {
            Write-CustomLog "Chocolatey is already installed."
        }
    } else {
        Write-CustomLog "InstallChocolatey flag is disabled. Skipping installation."
    }
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
', because 0215_Install-Chocolatey.ps1 should define Install-Chocolatey function, but it did not match.</message>
                      <stack-trace>[0] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[4] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[5] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[6] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[7] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[8] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[9] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[10] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[11] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[12] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[13] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[14] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[15] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[16] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[17] at $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:155
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="should have main execution logic" name="Core Application Scripts Tests.Script Content Analysis.should have main execution logic" time="0.0246" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should use standardized logging" name="Core Application Scripts Tests.Script Content Analysis.should use standardized logging" time="0.0259" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Core Application Cross-Platform Tests" executed="True" result="Failure" success="False" time="0.4639" asserts="0" description="Core Application Cross-Platform Tests">
            <results>
              <test-suite type="TestFixture" name="Core Application Cross-Platform Tests.Platform Compatibility" executed="True" result="Failure" success="False" time="0.0705" asserts="0" description="Core Application Cross-Platform Tests.Platform Compatibility">
                <results>
                  <test-case description="should work on current platform" name="Core Application Cross-Platform Tests.Platform Compatibility.should work on current platform" time="0.0049" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected collection @('Windows', 'Linux', 'macOS') to contain $null, but it was not found.</message>
                      <stack-trace>at $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS'), C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:230
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:230
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="should handle platform-specific scripts appropriately" name="Core Application Cross-Platform Tests.Platform Compatibility.should handle platform-specific scripts appropriately" time="0.014" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression '(IsWindows|Skip|platform)' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    # Check if WinRM is already configured
    $winrmStatus = Get-Service -Name WinRM -ErrorAction SilentlyContinue
    if ($winrmStatus -and $winrmStatus.Status -eq 'Running') {
        Write-CustomLog 'WinRM is already enabled and running.'
    } else {
        Write-CustomLog 'Enabling WinRM via Enable-PSRemoting -Force'
        # WinRM QuickConfig
        Enable-PSRemoting -Force
        Write-CustomLog 'Enable-PSRemoting executed'
        # Optionally configure additional authentication methods, etc.:
        # e.g.: Set-Item -Path WSMan:\localhost\Service\Auth\Basic -Value $true
    }
}
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
', because 0100_Enable-WinRM.ps1 should handle non-Windows platforms, but it did not match.
[1] Expected regular expression '(IsWindows|Skip|platform)' to match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    # Check current Remote Desktop status
    $currentStatus = Get-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name 'fDenyTSConnections'
    if ($Config.AllowRemoteDesktop -eq $true) {
        if ($currentStatus.fDenyTSConnections -eq 0) {
            Write-CustomLog "Remote Desktop is already enabled."
        }
        else {
            Write-CustomLog "Enabling Remote Desktop via Set-ItemProperty"
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                             -Name 'fDenyTSConnections' `
                             -Value 0
            Write-CustomLog "Remote Desktop enabled"
        }
    }
    else {
        if ($currentStatus.fDenyTSConnections -ne 1) {
            Write-CustomLog "Disabling Remote Desktop via Set-ItemProperty"
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                             -Name 'fDenyTSConnections' `
                             -Value 1
            Write-CustomLog "Remote Desktop disabled"
        }
        else {
            Write-CustomLog "Remote Desktop is already disabled."
        }
    }
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0101_Enable-RemoteDesktop.ps1 should handle non-Windows platforms, but it did not match.</message>
                      <stack-trace>[0] at $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:240
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:240
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:240
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:240
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="should use cross-platform paths" name="Core Application Cross-Platform Tests.Platform Compatibility.should use cross-platform paths" time="0.0427" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression '\\\\|C:\\' to not match '#Requires -Version 7.0
Param([object]$Config)
Import-Module "$env:PROJECT_ROOT/core-runner/modules/LabRunner/" -Force
Write-CustomLog "Starting $MyInvocation.MyCommand"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    &lt;#
.SYNOPSIS
    Removes the cloned repo and infra directories.
.DESCRIPTION
    Deletes the repository directory derived from RepoUrl under LocalPath
    and the InfraRepoPath directory if they exist.
#&gt;
    $tempPath = Get-CrossPlatformTempPath
    Push-Location -Path $tempPath
    try {
        $localBase = if ($Config.LocalPath) {
            $Config.LocalPath
        } else {
            Get-CrossPlatformTempPath
        }
        $localBase = System.Environment::ExpandEnvironmentVariables($localBase)
        $repoName = ($Config.RepoUrl -split '/') - 1 -replace '\.git$', ''
        $repoPath = Join-Path $localBase $repoName
        if (Test-Path $repoPath) {
            Write-CustomLog "Removing repo path '$repoPath'..."
            Remove-Item -Recurse -Force -Path $repoPath -ErrorAction Stop
        } else {
            Write-CustomLog "Repo path '$repoPath' not found; skipping."
        }
        $infraPath = if ($Config.InfraRepoPath) { $Config.InfraRepoPath } else { 'C:\\Temp\\base-infra' }
        if (Test-Path $infraPath) {
            Write-CustomLog "Removing infra path '$infraPath'..."
            Remove-Item -Recurse -Force -Path $infraPath -ErrorAction Stop
        } else {
            Write-CustomLog "Infra path '$infraPath' not found; skipping."
        }
        Write-CustomLog 'Cleanup completed successfully.'
    } catch {
        Write-Error -Message "Cleanup failed: $($PSItem.Exception.Message)`n$($PSItem.ScriptStackTrace)"
        exit 1
    } finally {
        try {
            Pop-Location -ErrorAction Stop
        } catch {
            Set-Location $tempPath
        }
    }
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
', because 0000_Cleanup-Files.ps1 should use cross-platform paths, but it did match.
[1] Expected regular expression '\\\\|C:\\' to not match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
Invoke-LabStep -Config $Config -Body {
    Write-CustomLog "Running $($MyInvocation.MyCommand.Name)"
    &lt;#
.SYNOPSIS
  Initialize OpenTofu using Hyper-V settings from config.json.
.DESCRIPTION
  - Reads InfraRepoUrl and InfraRepoPath from the passed-in config.
  - If InfraRepoUrl is provided, it clones the repo directly into InfraRepoPath.
  - Otherwise, generates a main.tf using Hyper-V config.
  - Checks that the tofu command is available, and if not, adds the known installation folder to PATH.
  - Runs 'tofu init' to initialize OpenTofu in InfraRepoPath.
#&gt;
    if ($Config.InitializeOpenTofu -eq $true) {
        Write-CustomLog '---- Hyper-V Configuration Check ----'
        Write-CustomLog 'Final Hyper-V configuration:'
        $Config.HyperV | Format-List        # --------------------------------------------------
        # 1) Determine infra repo path
        # --------------------------------------------------
        $infraRepoUrl = $Config.InfraRepoUrl
        $infraRepoPath = $Config.InfraRepoPath
        
        # Fallback if InfraRepoPath is not specified
        if ([string]::IsNullOrWhiteSpace($infraRepoPath)) {
            $infraRepoPath = Join-Path $scriptRoot 'my-infra'
        }
        Write-CustomLog "Using InfraRepoPath: $infraRepoPath"
        # Ensure local directory exists
        if (Test-Path $infraRepoPath) {
            Write-CustomLog "Directory already exists: $infraRepoPath"
        } else {
            if (-not (Test-Path $infraRepoPath)) { New-Item -ItemType Directory -Path $infraRepoPath -Force | Out-Null }
            Write-CustomLog "Created directory: $infraRepoPath"
        }
        
        # --------------------------------------------------
        # 2) If InfraRepoUrl is given, clone directly to InfraRepoPath
        # --------------------------------------------------
        if (-not [string]::IsNullOrWhiteSpace($infraRepoUrl)) {
            Write-CustomLog "InfraRepoUrl detected: $infraRepoUrl"
            if (Test-Path (Join-Path $infraRepoPath '.git')) {
                Write-CustomLog 'Directory exists. Pulling latest changes...'
                git -C $infraRepoPath pull
            } else {
                Write-CustomLog "Repository not found. Cloning $infraRepoUrl to $infraRepoPath..."
                gh repo clone $infraRepoUrl $infraRepoPath
                if ($LASTEXITCODE -ne 0) {
                    Write-Error "ERROR: Failed to clone $infraRepoUrl"
                    exit 1
                }
            }
        } else {
            Write-CustomLog 'No InfraRepoUrl provided. Using local or default .tf files.'
            # If no main.tf found, create one from Hyper-V config
            $tfFile = Join-Path -Path $infraRepoPath -ChildPath 'main.tf'
            if (-not (Test-Path $tfFile)) {
                Write-CustomLog 'No main.tf found; creating main.tf using Hyper-V configuration...'
                $tfContent = @'
terraform {
  required_providers {
    hyperv = {
      source  = "taliesins/hyperv"
      version = "1.2.1"
    }
  }
}
'@
                Set-Content -Path $tfFile -Value $tfContent
                Write-CustomLog "Created main.tf at $tfFile"
            } else {
                Write-CustomLog 'main.tf already exists; not overwriting.'
            }
            # If no provider.tf found, create one from Hyper-V config
            $ProviderFile = Join-Path -Path $infraRepoPath -ChildPath 'providers.tf'
            if (-not (Test-Path $ProviderFile)) {
                Write-CustomLog 'No providers.tf found; creating providers.tf using Hyper-V configuration...'
                $tfContent = @"
provider "hyperv" {
  user            = "$($Config.HyperV.User)"
  password        = "$($Config.HyperV.Password)"
  host            = "$($Config.HyperV.Host)"
  port            = $($Config.HyperV.Port)
  https           = $($Config.HyperV.Https.ToString().ToLower())
  insecure        = $($Config.HyperV.Insecure.ToString().ToLower())
  use_ntlm        = $($Config.HyperV.UseNtlm.ToString().ToLower())
  tls_server_name = "$($Config.HyperV.TlsServerName)"
  cacert_path     = "$($Config.HyperV.CacertPath)"
  cert_path       = "$($Config.HyperV.CertPath)"
  key_path        = "$($Config.HyperV.KeyPath)"
  script_path     = "$($Config.HyperV.ScriptPath)"
  timeout         = "$($Config.HyperV.Timeout)"
}
"@
                Set-Content -Path $ProviderFile -Value $tfContent
                Write-CustomLog "Created providers.tf at $ProviderFile"
            } else {
                Write-CustomLog 'providers.tf already exists; not overwriting.'
            }
        }
        # --------------------------------------------------
        # 3) Check if tofu is in the PATH. If not, attempt install and/or add it.
        # --------------------------------------------------
        $tofuCmd = Get-Command tofu -ErrorAction SilentlyContinue
        if (-not $tofuCmd) {
            $defaultTofuExe = Join-Path $env:LOCALAPPDATA -ChildPath 'Programs\\OpenTofu\\tofu.exe'
            if (Test-Path $defaultTofuExe) {
                Write-CustomLog 'Tofu command not found in PATH. Adding its folder to the session PATH...'
                $tofuFolder = Split-Path -Path $defaultTofuExe
                $env:PATH = "$env:PATH;$tofuFolder"
                $tofuCmd = Get-Command tofu -ErrorAction SilentlyContinue
                if (-not $tofuCmd) {
                    Write-Warning 'Even after updating PATH, tofu command is not recognized.'
                } else {
                    Write-CustomLog "Tofu command found: $($tofuCmd.Path)"
                }    
            } else {
                Write-Warning "Tofu executable not found at $defaultTofuExe. Attempting installation..."
                $cosign = Join-Path $Config.CosignPath 'cosign-windows-amd64.exe'
                $version = if ($Config.OpenTofuVersion) { $Config.OpenTofuVersion } else { 'latest' }
                
                if (Get-Command Invoke-OpenTofuInstaller -ErrorAction SilentlyContinue) {
                    Invoke-OpenTofuInstaller -CosignPath $cosign -OpenTofuVersion $version
                } else {
                    throw "Cannot install OpenTofu because the installer function 'Invoke-OpenTofuInstaller' is not available."
                }
                $tofuCmd = Get-Command tofu -ErrorAction SilentlyContinue
                if (-not $tofuCmd) {
                    throw 'Tofu still not found after installation. Please ensure OpenTofu is installed and in PATH.'
                }
            }
        }
        # --------------------------------------------------
        # 4) Run tofu init in InfraRepoPath
        # --------------------------------------------------
        Write-CustomLog "Initializing OpenTofu in $infraRepoPath..."
        Push-Location $infraRepoPath
        $exitCode = 0
        try {
            tofu init
        } catch {
            Write-Error "Failed to run 'tofu init'. Ensure OpenTofu is installed and available in the PATH."
            $exitCode = 1
        } finally {
            Pop-Location
        }
        if ($exitCode -ne 0) { exit $exitCode }
        Write-CustomLog 'OpenTofu initialized successfully.'
        Write-CustomLog @"
NEXT STEPS:
1. Check or edit the .tf files in '$infraRepoPath'.
2. You may need to modify variables.tf to match your Hyper-V configuration.
 - Set host, user, password, etc. to match your Hyper-V settings.
3. Run 'tofu plan' to preview changes.
4. Run 'tofu apply' to provision resources.
"@
        # Optionally place you in $infraRepoPath at the end
        Set-Location $infraRepoPath
        exit 0
    } else {
        Write-CustomLog 'InitializeOpenTofu flag is disabled. Skipping initialization.'
    }
    Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"
}
Write-CustomLog "Completed $($MyInvocation.MyCommand.Name)"', because 0009_Initialize-OpenTofu.ps1 should use cross-platform paths, but it did match.
[2] Expected regular expression '\\\\|C:\\' to not match '#Requires -Version 7.0
[CmdletBinding(SupportsShouldProcess)]
param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [object]$Config
)
Import-Module "$env:PWSH_MODULES_PATH/LabRunner/" -Force
Import-Module "$env:PROJECT_ROOT/core-runner/modules/Logging" -Force
Write-CustomLog "Starting $($MyInvocation.MyCommand.Name)"
#region Helper Functions
function Convert-CerToPem {
    &lt;#
    .SYNOPSIS
        Converts a CER certificate file to PEM format
    #&gt;
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$CerPath,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$PemPath
    )
    
    if (-not $PSCmdlet.ShouldProcess($PemPath, 'Create PEM file')) { return }
    
    try {
        if (-not (Test-Path $CerPath)) {
            throw "Certificate file not found: $CerPath"
        }
        
        $bytes = [System.IO.File]::ReadAllBytes($CerPath)
        $b64 = [System.Convert]::ToBase64String($bytes, 'InsertLineBreaks')
        $pemContent = "-----BEGIN CERTIFICATE-----`n$b64`n-----END CERTIFICATE-----"
        
        Set-Content -Path $PemPath -Value $pemContent -Encoding UTF8
        Write-CustomLog "Converted certificate to PEM format: $PemPath" -Level INFO
    } catch {
        Write-CustomLog "Failed to convert certificate to PEM: $($_.Exception.Message)" -Level ERROR
        throw
    }
}
function Convert-PfxToPem {
    &lt;#
    .SYNOPSIS
        Converts a PFX certificate file to separate PEM certificate and key files
    #&gt;
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$PfxPath,
        
        [Parameter(Mandatory)]
        [System.Security.SecureString]$Password,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$CertPath,
        
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$KeyPath
    )
    
    if (-not $PSCmdlet.ShouldProcess($PfxPath, 'Convert PFX to PEM')) { return }
    
    if (-not (Test-Path $PfxPath) -or ((Get-Item -Path $PfxPath -ErrorAction SilentlyContinue).Length -eq 0)) {
        throw "Invalid or unreadable PFX at $PfxPath"
    }
    
    try {
        $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2(
            $PfxPath,
            $Password,
            [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
        )
        
        # Export certificate
        $certBytes = $cert.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert)
        $certB64 = [System.Convert]::ToBase64String($certBytes, 'InsertLineBreaks')
        
        if ($PSCmdlet.ShouldProcess($CertPath, 'Write certificate PEM')) {
            $certPem = "-----BEGIN CERTIFICATE-----`n$certB64`n-----END CERTIFICATE-----"
            Set-Content -Path $CertPath -Value $certPem -Encoding UTF8
        }
        
        # Export private key
        $keyBytes = $cert.PrivateKey.ExportPkcs8PrivateKey()
        $keyB64 = [System.Convert]::ToBase64String($keyBytes, 'InsertLineBreaks')
        
        if ($PSCmdlet.ShouldProcess($KeyPath, 'Write key PEM')) {
            $keyPem = "-----BEGIN PRIVATE KEY-----`n$keyB64`n-----END PRIVATE KEY-----"
            Set-Content -Path $KeyPath -Value $keyPem -Encoding UTF8
        }
        
        Write-CustomLog "Converted PFX to PEM files: $CertPath, $KeyPath" -Level INFO
    } catch [System.Security.Cryptography.CryptographicException] {
        Write-CustomLog "Failed to convert certificate: $($_.Exception.Message)" -Level ERROR
        throw "Failed to convert certificate: $($_.Exception.Message)"
    } catch {
        Write-CustomLog "Unexpected error during PFX conversion: $($_.Exception.Message)" -Level ERROR
        throw
    }
}
function Get-HyperVProviderVersion {
    &lt;#
    .SYNOPSIS
        Gets the HyperV provider version from configuration or uses default
    #&gt;
    [CmdletBinding()]
    param()
    
    $defaultVersion = '1.2.1'
    
    if ($Config -and $Config.HyperV -and $Config.HyperV.ProviderVersion) {
        Write-CustomLog "Using configured HyperV provider version: $($Config.HyperV.ProviderVersion)" -Level INFO
        return $Config.HyperV.ProviderVersion
    }
    
    Write-CustomLog "HyperV provider version not specified in config. Using default: $defaultVersion" -Level WARN
    return $defaultVersion
}
#endregion
#region Main Execution
if ($MyInvocation.InvocationName -ne '.') {
    try {
        Invoke-LabStep -Config $Config -Body {
            Write-CustomLog 'Configuring HyperV Provider for OpenTofu' -Level INFO
            
            # Only proceed if HyperV host preparation is enabled
            if (-not $Config.PrepareHyperVHost) {
                Write-CustomLog 'HyperV host preparation is disabled in configuration' -Level WARN
                return
            }
            
            # Validate Windows platform
            if (-not $IsWindows) {
                Write-CustomLog 'HyperV provider setup requires Windows platform' -Level ERROR
                throw 'HyperV provider setup is only supported on Windows'
            }
            
            # Get infrastructure repository path
            $infraRepoPath = if ([string]::IsNullOrWhiteSpace($Config.InfraRepoPath)) {
                Join-Path $PSScriptRoot '../../../opentofu/infrastructure'
            } else {
                $Config.InfraRepoPath
            }
            
            Write-CustomLog "Using infrastructure repository path: $infraRepoPath" -Level INFO
            
            # Ensure infrastructure directory exists
            if (-not (Test-Path $infraRepoPath)) {
                New-Item -ItemType Directory -Path $infraRepoPath -Force | Out-Null
                Write-CustomLog "Created infrastructure directory: $infraRepoPath" -Level INFO
            }
            
            #region Enable HyperV Feature
            Write-CustomLog 'Checking HyperV feature status...' -Level INFO
            
            try {
                $hvFeature = Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -ErrorAction Stop
                if ($hvFeature.State -ne 'Enabled') {
                    Write-CustomLog 'Enabling HyperV feature...' -Level INFO
                    if ($PSCmdlet.ShouldProcess('Microsoft-Hyper-V', 'Enable Windows Feature')) {
                        Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All -NoRestart
                        Write-CustomLog 'HyperV feature enabled successfully' -Level SUCCESS
                    }
                } else {
                    Write-CustomLog 'HyperV feature is already enabled' -Level INFO
                }
            } catch {
                Write-CustomLog "Failed to check/enable HyperV feature: $($_.Exception.Message)" -Level ERROR
                throw
            }
            #endregion
            
            #region Configure WinRM
            Write-CustomLog 'Configuring WinRM for HyperV provider...' -Level INFO
            
            try {
                # Test if WinRM is already enabled
                try {
                    Test-WSMan -ComputerName localhost -ErrorAction Stop | Out-Null
                    Write-CustomLog 'WinRM is already enabled' -Level INFO
                } catch {
                    Write-CustomLog 'Enabling WinRM...' -Level INFO
                    if ($PSCmdlet.ShouldProcess('WinRM', 'Enable PS Remoting')) {
                        Enable-PSRemoting -SkipNetworkProfileCheck -Force
                        Write-CustomLog 'WinRM enabled successfully' -Level SUCCESS
                    }
                }
                
                # Configure WinRM settings
                $winrmConfig = @{
                    MaxMemoryPerShellMB = 1024
                    MaxTimeoutms        = 1800000
                }
                
                foreach ($setting in $winrmConfig.GetEnumerator()) {
                    $resourceUri = if ($setting.Key -eq 'MaxMemoryPerShellMB') { 
                        'winrm/config/WinRS' 
                    } else { 
                        'winrm/config' 
                    }
                    
                    try {
                        $current = (Get-WSManInstance -ResourceURI $resourceUri).$($setting.Key)
                        if ($current -ne $setting.Value) {
                            Write-CustomLog "Setting WinRM $($setting.Key) to $($setting.Value)..." -Level INFO
                            if ($PSCmdlet.ShouldProcess($setting.Key, 'Set WinRM Configuration')) {
                                Set-WSManInstance -ResourceURI $resourceUri -ValueSet @{$($setting.Key) = $setting.Value }
                            }
                        } else {
                            Write-CustomLog "WinRM $($setting.Key) is already set to $($setting.Value)" -Level INFO
                        }
                    } catch {
                        Write-CustomLog "Failed to configure WinRM $($setting.Key): $($_.Exception.Message)" -Level WARN
                    }
                }
                
                # Configure TrustedHosts
                try {
                    $currentTrustedHosts = (Get-WSManInstance -ResourceURI winrm/config/Client).TrustedHosts
                    if ($currentTrustedHosts -ne '*') {
                        Write-CustomLog "Setting TrustedHosts to '*'..." -Level INFO
                        if ($PSCmdlet.ShouldProcess('TrustedHosts', "Set to '*'")) {
                            Set-WSManInstance -ResourceURI winrm/config/Client -ValueSet @{TrustedHosts = '*' }
                        }
                    } else {
                        Write-CustomLog "TrustedHosts is already set to '*'" -Level INFO
                    }
                } catch {
                    Write-CustomLog "TrustedHosts setting may be controlled by policy: $($_.Exception.Message)" -Level WARN
                }
                
                # Enable Negotiate authentication
                try {
                    $currentNegotiate = (Get-WSManInstance -ResourceURI winrm/config/Service/Auth).Negotiate
                    if (-not $currentNegotiate) {
                        Write-CustomLog 'Enabling Negotiate authentication...' -Level INFO
                        if ($PSCmdlet.ShouldProcess('Negotiate', 'Enable Authentication')) {
                            Set-WSManInstance -ResourceURI winrm/config/Service/Auth -ValueSet @{Negotiate = $true }
                        }
                    } else {
                        Write-CustomLog 'Negotiate authentication is already enabled' -Level INFO
                    }
                } catch {
                    Write-CustomLog "Failed to configure Negotiate authentication: $($_.Exception.Message)" -Level WARN
                }
            } catch {
                Write-CustomLog "Failed to configure WinRM: $($_.Exception.Message)" -Level ERROR
                throw
            }
            #endregion
            
            #region Certificate Management
            Write-CustomLog 'Setting up certificates for secure WinRM...' -Level INFO
            
            # Get certificate configuration
            $rootCaName = if ($Config.CertificateAuthority -and $Config.CertificateAuthority.CommonName) {
                $Config.CertificateAuthority.CommonName
            } else {
                'DevRootCA'
            }
            
            $rootCaPassword = ConvertTo-SecureString 'P@ssw0rd' -AsPlainText -Force
            $hostPassword = ConvertTo-SecureString 'P@ssw0rd' -AsPlainText -Force
            
            # Create or import Root CA certificate
            Write-CustomLog "Processing Root CA certificate: $rootCaName" -Level INFO
            $rootCaCertificate = Get-ChildItem cert:\LocalMachine\Root | Where-Object { $_.Subject -eq "CN=$rootCaName" }
            
            if (-not $rootCaCertificate) {
                $cerPath = ".\$rootCaName.cer"
                $pfxPath = ".\$rootCaName.pfx"
                
                # Clean up existing certificates in My store
                Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$rootCaName" } | Remove-Item -Force -ErrorAction SilentlyContinue
                
                if ((Test-Path $cerPath) -and (Test-Path $pfxPath)) {
                    Write-CustomLog 'Importing existing Root CA certificates...' -Level INFO
                    if ($PSCmdlet.ShouldProcess($rootCaName, 'Import existing certificates')) {
                        Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\LocalMachine\Root -Password $rootCaPassword -Exportable | Out-Null
                        Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\LocalMachine\My -Password $rootCaPassword -Exportable | Out-Null
                    }
                } else {
                    Write-CustomLog 'Creating new Root CA certificate...' -Level INFO
                    
                    # Remove existing files
                    Remove-Item $cerPath -Force -ErrorAction SilentlyContinue
                    Remove-Item $pfxPath -Force -ErrorAction SilentlyContinue
                    
                    $rootCaParams = @{
                        Type              = 'Custom'
                        DnsName           = $rootCaName
                        Subject           = "CN=$rootCaName"
                        KeyExportPolicy   = 'Exportable'
                        CertStoreLocation = 'Cert:\LocalMachine\My'
                        KeyUsageProperty  = 'All'
                        KeyUsage          = 'None'
                        Provider          = 'Microsoft Strong Cryptographic Provider'
                        KeySpec           = 'KeyExchange'
                        KeyLength         = 4096
                        HashAlgorithm     = 'SHA256'
                        KeyAlgorithm      = 'RSA'
                        NotAfter          = (Get-Date).AddYears(5)
                    }
                    
                    if ($PSCmdlet.ShouldProcess($rootCaName, 'Create Root CA certificate')) {
                        $rootCaCertificate = New-SelfSignedCertificate @rootCaParams
                        
                        Export-Certificate -Cert $rootCaCertificate -FilePath $cerPath | Out-Null
                        Export-PfxCertificate -Cert $rootCaCertificate -FilePath $pfxPath -Password $rootCaPassword | Out-Null
                        
                        # Remove from My store and import to Root and My stores
                        Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$rootCaName" } | Remove-Item -Force
                        Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\LocalMachine\Root -Password $rootCaPassword -Exportable | Out-Null
                        Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\LocalMachine\My -Password $rootCaPassword -Exportable | Out-Null
                    }
                }
                
                $rootCaCertificate = Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$rootCaName" }
            }
            
            # Create host certificate
            $hostName = [System.Net.Dns]::GetHostName()
            Write-CustomLog "Processing host certificate for: $hostName" -Level INFO
            
            $hostCertificate = Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$hostName" }
            
            if (-not $hostCertificate) {
                Write-CustomLog 'Creating host certificate...' -Level INFO
                
                # Clean up existing files
                Remove-Item ".\$hostName.cer" -Force -ErrorAction SilentlyContinue
                Remove-Item ".\$hostName.pfx" -Force -ErrorAction SilentlyContinue
                Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$hostName" } | Remove-Item -Force -ErrorAction SilentlyContinue
                
                $dnsNames = @($hostName, 'localhost', '127.0.0.1')
                try {
                    $dnsNames += [System.Net.Dns]::GetHostByName($env:ComputerName).AddressList.IPAddressToString
                } catch {
                    Write-CustomLog 'Could not resolve additional IP addresses for certificate' -Level WARN
                }
                
                $hostCertParams = @{
                    Type              = 'Custom'
                    DnsName           = $dnsNames
                    Subject           = "CN=$hostName"
                    KeyExportPolicy   = 'Exportable'
                    CertStoreLocation = 'Cert:\LocalMachine\My'
                    KeyUsageProperty  = 'All'
                    KeyUsage          = @('KeyEncipherment', 'DigitalSignature', 'NonRepudiation')
                    TextExtension     = @('2.5.29.37={text}1.3.6.1.5.5.7.3.1,1.3.6.1.5.5.7.3.2')
                    Signer            = $rootCaCertificate
                    Provider          = 'Microsoft Strong Cryptographic Provider'
                    KeySpec           = 'KeyExchange'
                    KeyLength         = 2048
                    HashAlgorithm     = 'SHA256'
                    KeyAlgorithm      = 'RSA'
                    NotAfter          = (Get-Date).AddYears(2)
                }
                
                if ($PSCmdlet.ShouldProcess($hostName, 'Create host certificate')) {
                    $hostCertificate = New-SelfSignedCertificate @hostCertParams
                    
                    Export-Certificate -Cert $hostCertificate -FilePath ".\$hostName.cer" | Out-Null
                    Export-PfxCertificate -Cert $hostCertificate -FilePath ".\$hostName.pfx" -Password $hostPassword | Out-Null
                    
                    # Reimport to ensure it's available
                    Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$hostName" } | Remove-Item -Force
                    Import-PfxCertificate -FilePath ".\$hostName.pfx" -CertStoreLocation Cert:\LocalMachine\My -Password $hostPassword -Exportable | Out-Null
                    
                    $hostCertificate = Get-ChildItem cert:\LocalMachine\My | Where-Object { $_.Subject -eq "CN=$hostName" }
                }
            }
            
            # Convert certificates to PEM format
            Write-CustomLog 'Converting certificates to PEM format...' -Level INFO
            
            if ($PSCmdlet.ShouldProcess('Certificates', 'Convert to PEM format')) {
                Convert-CerToPem -CerPath ".\$rootCaName.cer" -PemPath ".\$rootCaName.pem"
                Convert-PfxToPem -PfxPath ".\$hostName.pfx" -Password $hostPassword -CertPath ".\$hostName.pem" -KeyPath ".\$hostName-key.pem"
                
                # Copy PEM files to infrastructure directory
                $pemFiles = @(
                    @{ Source = ".\$rootCaName.pem"; Dest = Join-Path $infraRepoPath "$rootCaName.pem" }
                    @{ Source = ".\$hostName.pem"; Dest = Join-Path $infraRepoPath "$hostName.pem" }
                    @{ Source = ".\$hostName-key.pem"; Dest = Join-Path $infraRepoPath "$hostName-key.pem" }
                )
                
                foreach ($file in $pemFiles) {
                    if (Test-Path $file.Dest) {
                        Remove-Item $file.Dest -Force
                    }
                    Copy-Item $file.Source -Destination $file.Dest -Force
                    Write-CustomLog "Copied $($file.Source) to $($file.Dest)" -Level INFO
                }
            }
            #endregion
            
            #region Configure WinRM HTTPS Listener
            Write-CustomLog 'Configuring WinRM HTTPS listener...' -Level INFO
            
            try {
                # Remove existing HTTPS listener
                Get-ChildItem wsman:\localhost\Listener\ | Where-Object { $_.Keys -eq 'Transport=HTTPS' } | Remove-Item -Recurse -ErrorAction SilentlyContinue
                
                if ($PSCmdlet.ShouldProcess('WinRM HTTPS Listener', 'Create')) {
                    New-Item -Path WSMan:\localhost\Listener -Transport HTTPS -Address * -CertificateThumbPrint $hostCertificate.Thumbprint -Force | Out-Null
                    Write-CustomLog "WinRM HTTPS listener created with certificate thumbprint: $($hostCertificate.Thumbprint)" -Level SUCCESS
                }
                
                # Restart WinRM service
                if ($PSCmdlet.ShouldProcess('WinRM', 'Restart Service')) {
                    Restart-Service WinRM -Force
                    Write-CustomLog 'WinRM service restarted' -Level INFO
                }
                
                # Configure firewall rule for HTTPS
                $httpsRule = Get-NetFirewallRule -Name 'WinRMHTTPSIn' -ErrorAction SilentlyContinue
                if (-not $httpsRule) {
                    if ($PSCmdlet.ShouldProcess('Firewall', 'Allow WinRM HTTPS (5986)')) {
                        New-NetFirewallRule -DisplayName 'Windows Remote Management (HTTPS-In)' -Name 'WinRMHTTPSIn' -Profile Any -LocalPort 5986 -Protocol TCP | Out-Null
                        Write-CustomLog 'Firewall rule created for WinRM HTTPS (port 5986)' -Level SUCCESS
                    }
                } else {
                    Write-CustomLog 'Firewall rule for WinRM HTTPS already exists' -Level INFO
                }
            } catch {
                Write-CustomLog "Failed to configure WinRM HTTPS listener: $($_.Exception.Message)" -Level ERROR
                throw
            }
            #endregion
            
            #region Install HyperV Provider
            Write-CustomLog 'Installing HyperV provider...' -Level INFO
            
            try {
                $providerVersion = Get-HyperVProviderVersion
                
                # Determine OS and architecture
                $computerInfo = Get-ComputerInfo -Property OsName, OsArchitecture
                $os = 'windows'
                $arch = if ($computerInfo.OsArchitecture -match '64') { 'amd64' } else { '386' }
                
                Write-CustomLog "Target platform: $os/$arch, Provider version: $providerVersion" -Level INFO
                
                # Download provider binary
                $registryEndpoint = "https://registry.terraform.io/v1/providers/taliesins/hyperv/$providerVersion/download/$os/$arch"
                
                try {
                    $response = Invoke-RestMethod -Uri $registryEndpoint -Method Get
                    $downloadUrl = $response.download_url
                    $zipPath = Join-Path $env:TEMP "terraform-provider-hyperv_$providerVersion.zip"
                    
                    Write-CustomLog "Downloading HyperV provider from: $downloadUrl" -Level INFO
                    Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath
                    
                    # Extract provider
                    $tempDir = Join-Path $env:TEMP 'hyperv-provider-extract'
                    if (Test-Path $tempDir) {
                        Remove-Item $tempDir -Recurse -Force
                    }
                    
                    Expand-Archive -Path $zipPath -DestinationPath $tempDir -Force
                    
                    # Find provider executable
                    $providerExe = Get-ChildItem $tempDir -Filter 'terraform-provider-hyperv*.exe' | Select-Object -First 1
                    if (-not $providerExe) {
                        throw 'Provider executable not found in downloaded archive'
                    }
                    
                    # Install to OpenTofu provider directory
                    $hypervProviderDir = Join-Path $infraRepoPath ".terraform/providers/registry.opentofu.org/taliesins/hyperv/$providerVersion/${os}_${arch}"
                    if (-not (Test-Path $hypervProviderDir)) {
                        New-Item -ItemType Directory -Path $hypervProviderDir -Force | Out-Null
                    }
                    
                    $destinationBinary = Join-Path $hypervProviderDir 'terraform-provider-hyperv.exe'
                    if (Test-Path $destinationBinary) {
                        Remove-Item $destinationBinary -Force
                    }
                    
                    Copy-Item $providerExe.FullName -Destination $destinationBinary -Force
                    Write-CustomLog "HyperV provider installed to: $destinationBinary" -Level SUCCESS
                    
                    # Cleanup
                    Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
                    Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
                } catch {
                    Write-CustomLog "Failed to download/install HyperV provider: $($_.Exception.Message)" -Level ERROR
                    throw
                }
            } catch {
                Write-CustomLog "HyperV provider installation failed: $($_.Exception.Message)" -Level ERROR
                throw
            }
            #endregion
            
            #region Update Provider Configuration
            $tfFile = Join-Path $infraRepoPath 'providers.tf'
            if (Test-Path $tfFile) {
                Write-CustomLog 'Updating providers.tf configuration...' -Level INFO
                
                try {
                    $rootCAPath = (Resolve-Path (Join-Path $infraRepoPath "$rootCaName.pem")).Path
                    $hostCertPath = (Resolve-Path (Join-Path $infraRepoPath "$hostName.pem")).Path
                    $hostKeyPath = (Resolve-Path (Join-Path $infraRepoPath "$hostName-key.pem")).Path
                    
                    # Escape backslashes for Terraform
                    $escapedRootCAPath = $rootCAPath.Replace('\', '\\')
                    $escapedHostCertPath = $hostCertPath.Replace('\', '\\')
                    $escapedHostKeyPath = $hostKeyPath.Replace('\', '\\')
                    
                    $content = Get-Content $tfFile -Raw
                    $content = $content -replace '(insecure\s*=\s*)(true|false)', '${1}false'
                    $content = $content -replace '(tls_server_name\s*=\s*")[^"]*"', ('${1}' + $hostName + '"')
                    $content = $content -replace '(cacert_path\s*=\s*")[^"]*"', ('${1}' + $escapedRootCAPath + '"')
                    $content = $content -replace '(cert_path\s*=\s*")[^"]*"', ('${1}' + $escapedHostCertPath + '"')
                    $content = $content -replace '(key_path\s*=\s*")[^"]*"', ('${1}' + $escapedHostKeyPath + '"')
                    
                    Set-Content -Path $tfFile -Value $content
                    Write-CustomLog 'Updated providers.tf with certificate paths' -Level SUCCESS
                } catch {
                    Write-CustomLog "Failed to update providers.tf: $($_.Exception.Message)" -Level WARN
                }
            } else {
                Write-CustomLog "providers.tf not found in $infraRepoPath - skipping configuration update" -Level WARN
            }
            #endregion
            
            Write-CustomLog 'HyperV Provider preparation completed successfully' -Level SUCCESS
            Write-CustomLog 'You can now test the connection using Enter-PSSession with the configured certificates' -Level INFO
        }
    } catch {
        Write-CustomLog "HyperV Provider preparation failed: $($_.Exception.Message)" -Level ERROR
        throw
    }
}
#endregion
', because 0010_Prepare-HyperVProvider.ps1 should use cross-platform paths, but it did match.</message>
                      <stack-trace>[0] at $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:249
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:249
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:249
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:249
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:249
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:249
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
          <test-suite type="TestFixture" name="Automated Test Generation and Validation" executed="True" result="Failure" success="False" time="0.7723" asserts="0" description="Automated Test Generation and Validation">
            <results>
              <test-suite type="TestFixture" name="Automated Test Generation and Validation.Continuous Test Coverage" executed="True" result="Failure" success="False" time="0.2963" asserts="0" description="Automated Test Generation and Validation.Continuous Test Coverage">
                <results>
                  <test-case description="should have tests for all core scripts" name="Automated Test Generation and Validation.Continuous Test Coverage.should have tests for all core scripts" time="0.2211" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected regular expression '0000_Cleanup-Files' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0000_Cleanup-Files, but it did not match.
[1] Expected regular expression '0001_Reset-Git' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0001_Reset-Git, but it did not match.
[2] Expected regular expression '0002_Setup-Directories' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0002_Setup-Directories, but it did not match.
[3] Expected regular expression '0006_Install-ValidationTools' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0006_Install-ValidationTools, but it did not match.
[4] Expected regular expression '0007_Install-Go' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0007_Install-Go, but it did not match.
[5] Expected regular expression '0008_Install-OpenTofu' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0008_Install-OpenTofu, but it did not match.
[6] Expected regular expression '0009_Initialize-OpenTofu' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0009_Initialize-OpenTofu, but it did not match.
[7] Expected regular expression '0010_Prepare-HyperVProvider' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0010_Prepare-HyperVProvider, but it did not match.
[8] Expected regular expression '0100_Enable-WinRM' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0100_Enable-WinRM, but it did not match.
[9] Expected regular expression '0101_Enable-RemoteDesktop' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0101_Enable-RemoteDesktop, but it did not match.
[10] Expected regular expression '0102_Configure-Firewall' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0102_Configure-Firewall, but it did not match.
[11] Expected regular expression '0103_Change-ComputerName' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0103_Change-ComputerName, but it did not match.
[12] Expected regular expression '0104_Install-CA' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0104_Install-CA, but it did not match.
[13] Expected regular expression '0105_Install-HyperV' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0105_Install-HyperV, but it did not match.
[14] Expected regular expression '0106_Install-WAC' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0106_Install-WAC, but it did not match.
[15] Expected regular expression '0111_Disable-TCPIP6' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0111_Disable-TCPIP6, but it did not match.
[16] Expected regular expression '0112_Enable-PXE' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0112_Enable-PXE, but it did not match.
[17] Expected regular expression '0113_Config-DNS' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0113_Config-DNS, but it did not match.
[18] Expected regular expression '0114_Config-TrustedHosts' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0114_Config-TrustedHosts, but it did not match.
[19] Expected regular expression '0200_Get-SystemInfo' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0200_Get-SystemInfo, but it did not match.
[20] Expected regular expression '0201_Install-NodeCore' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0201_Install-NodeCore, but it did not match.
[21] Expected regular expression '0202_Install-NodeGlobalPackages' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0202_Install-NodeGlobalPackages, but it did not match.
[22] Expected regular expression '0203_Install-npm' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0203_Install-npm, but it did not match.
[23] Expected regular expression '0204_Install-Poetry' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0204_Install-Poetry, but it did not match.
[24] Expected regular expression '0205_Install-Sysinternals' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0205_Install-Sysinternals, but it did not match.
[25] Expected regular expression '0206_Install-Python' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0206_Install-Python, but it did not match.
[26] Expected regular expression '0207_Install-Git' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0207_Install-Git, but it did not match.
[27] Expected regular expression '0208_Install-DockerDesktop' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0208_Install-DockerDesktop, but it did not match.
[28] Expected regular expression '0209_Install-7Zip' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0209_Install-7Zip, but it did not match.
[29] Expected regular expression '0210_Install-VSCode' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0210_Install-VSCode, but it did not match.
[30] Expected regular expression '0211_Install-VSBuildTools' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0211_Install-VSBuildTools, but it did not match.
[31] Expected regular expression '0212_Install-AzureCLI' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0212_Install-AzureCLI, but it did not match.
[32] Expected regular expression '0213_Install-AWSCLI' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0213_Install-AWSCLI, but it did not match.
[33] Expected regular expression '0214_Install-Packer' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0214_Install-Packer, but it did not match.
[34] Expected regular expression '0215_Install-Chocolatey' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0215_Install-Chocolatey, but it did not match.
[35] Expected regular expression '0216_Set-LabProfile' to match '#Requires -Version 7.0
#Requires -Module Pester
&lt;#
.SYNOPSIS
    Comprehensive Pester tests for the CoreApp module and its scripts
    
.DESCRIPTION
    Tests the core application functionality including:
    - Module loading and configuration
    - Individual script execution
    - Cross-platform compatibility
    - Error handling and validation
    - Integration with PatchManager workflow
#&gt;
BeforeAll {
    # Set up environment variables if not already set
    if (-not $env:PROJECT_ROOT) {
        $env:PROJECT_ROOT = Split-Path (Split-Path $PSScriptRoot -Parent) -Parent
    }
    if (-not $env:PWSH_MODULES_PATH) {
        $env:PWSH_MODULES_PATH = Join-Path $env:PROJECT_ROOT "core-runner/modules"
    }
    
    # Import required modules and helpers  
    try {
        Import-Module "$env:PWSH_MODULES_PATH/Logging/" -Force -ErrorAction SilentlyContinue
        Import-Module "$env:PWSH_MODULES_PATH/PatchManager/" -Force -ErrorAction SilentlyContinue
    } catch {
        Write-Warning "Some modules could not be loaded: $_"
    }
    
    # Import test helpers if they exist
    $testHelpersPath = "$env:PROJECT_ROOT/tests/helpers/TestHelpers.ps1"
    if (Test-Path $testHelpersPath) {
        . $testHelpersPath
    }
    
    $scriptAstPath = "$env:PROJECT_ROOT/tests/helpers/Get-ScriptAst.ps1"
    if (Test-Path $scriptAstPath) {
        . $scriptAstPath
    }
    
    # Set up test environment
    $script:CoreAppPath = "$env:PROJECT_ROOT/core-runner/core_app"
    $script:DefaultConfigPath = "$script:CoreAppPath/default-config.json"
    $script:TestResults = @{}
    
    # Ensure test coverage directory exists
    if (-not (Test-Path "$env:PROJECT_ROOT/coverage")) {
        New-Item -ItemType Directory -Path "$env:PROJECT_ROOT/coverage" -Force | Out-Null
    }
}
Describe "CoreApp Module Tests" -Tag @('Critical', 'CoreApp', 'Module') {
    
    Context "Module Structure Validation" {
        
        It "should have valid module manifest" {
            $manifestPath = Join-Path $script:CoreAppPath "CoreApp.psd1"
            $manifestPath | Should -Exist
            
            { Test-ModuleManifest -Path $manifestPath } | Should -Not -Throw
        }
        
        It "should have module implementation file" {
            $modulePath = Join-Path $script:CoreAppPath "CoreApp.psm1"
            $modulePath | Should -Exist
              # Validate PowerShell syntax
            $errors = $null
            [System.Management.Automation.Language.Parser]::ParseFile($modulePath, [ref]$null, [ref]$errors) | Out-Null
            $errorCount = if ($errors) { $errors.Count } else { 0 }
            $errorCount | Should -Be 0
        }
        
        It "should have default configuration file" {
            $script:DefaultConfigPath | Should -Exist
            
            # Validate JSON structure
            { Get-Content $script:DefaultConfigPath | ConvertFrom-Json } | Should -Not -Throw
        }
        
        It "should have scripts directory with core scripts" {
            $scriptsPath = Join-Path $script:CoreAppPath "scripts"
            $scriptsPath | Should -Exist
            
            $coreScripts = Get-ChildItem -Path $scriptsPath -Filter "*.ps1"
            $coreScripts.Count | Should -BeGreaterThan 10
        }
    }
    
    Context "Module Import and Loading" {
        
        It "should import CoreApp module successfully" {
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should export Invoke-CoreApplication function" {
            Import-Module "$script:CoreAppPath/" -Force
            Get-Command -Module CoreApp -Name "Invoke-CoreApplication" | Should -Not -BeNullOrEmpty
        }
        
        It "should have proper environment variable support" {
            $env:PROJECT_ROOT | Should -Not -BeNullOrEmpty
            $env:PWSH_MODULES_PATH | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Scripts Tests" -Tag @('Important', 'CoreApp', 'Scripts') {
    
    BeforeAll {
        $script:CoreScripts = Get-ChildItem -Path "$script:CoreAppPath/scripts" -Filter "*.ps1"
    }
    
    Context "Script Syntax and Structure Validation" {
        
        It "should have valid PowerShell syntax for all core scripts" {            foreach ($script in $script:CoreScripts) {
                $errors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($script.FullName, [ref]$null, [ref]$errors) | Out-Null
                $errorCount = if ($errors) { $errors.Count } else { 0 }
                $errorCount | Should -Be 0 -Because "Script $($script.Name) should have valid syntax"
            }
        }
        
        It "should follow PowerShell 7.0+ requirements" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match '#Requires') {
                    $content | Should -Match '#Requires -Version 7\.0' -Because "$($script.Name) should require PowerShell 7.0+"
                }
            }
        }
        
        It "should use proper error handling patterns" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for try-catch blocks in scripts that are likely to have them
                if ($script.Name -match '^(0[12]|Install-)') {
                    $content | Should -Match 'try\s*\{[\s\S]*?\}\s*catch' -Because "$($script.Name) should use try-catch error handling"
                }
            }
        }
    }
    
    Context "Script Content Analysis" {
        
        It "should define expected functions in numbered scripts" {
            $installerScripts = $script:CoreScripts | Where-Object { $_.Name -match '^0\d+_Install-' }
            
            foreach ($script in $installerScripts) {
                $content = Get-Content $script.FullName -Raw
                $expectedFunctionName = ($script.BaseName -replace '^\d+_', '')
                $content | Should -Match "function\s+$expectedFunctionName" -Because "$($script.Name) should define $expectedFunctionName function"
            }
        }
        
        It "should have main execution logic" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for main execution patterns
                ($content -match 'param\s*\(' -or $content -match '\$Config' -or $content -match 'Write-CustomLog') | 
                    Should -BeTrue -Because "$($script.Name) should have main execution logic"
            }
        }
        
        It "should use standardized logging" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($content -match 'Write-') {
                    $content | Should -Match 'Write-CustomLog' -Because "$($script.Name) should use Write-CustomLog for standardized logging"
                }
            }
        }
    }
}
Describe "Core Application Integration Tests" -Tag @('Important', 'CoreApp', 'Integration') {
    
    Context "Invoke-CoreApplication Function Tests" {
        
        BeforeAll {
            Import-Module "$script:CoreAppPath/" -Force
        }
        
        It "should accept ConfigPath parameter" {
            $function = Get-Command Invoke-CoreApplication
            $function.Parameters.ContainsKey('ConfigPath') | Should -BeTrue
        }
        
        It "should validate configuration file exists" {
            $tempConfig = Join-Path ([System.IO.Path]::GetTempPath()) "test-config.json"
            '{"test": true}' | Set-Content -Path $tempConfig
            
            try {
                { Invoke-CoreApplication -ConfigPath $tempConfig } | Should -Not -Throw
            } finally {
                Remove-Item $tempConfig -Force -ErrorAction SilentlyContinue
            }
        }
        
        It "should handle missing configuration gracefully" {
            $nonExistentConfig = Join-Path ([System.IO.Path]::GetTempPath()) "nonexistent-config.json"
            { Invoke-CoreApplication -ConfigPath $nonExistentConfig } | Should -Throw
        }
    }
    
    Context "PatchManager Integration" {
        
        It "should be compatible with PatchManager workflow" {
            # Test that CoreApp can be used within PatchManager
            { Import-Module "$env:PROJECT_ROOT/core-runner/modules/PatchManager/" -Force } | Should -Not -Throw
            { Import-Module "$script:CoreAppPath/" -Force } | Should -Not -Throw
        }
        
        It "should support PatchManager change tracking" {
            # Verify that changes to CoreApp can be tracked by PatchManager
            $patchManager = Get-Command New-PatchOperation -ErrorAction SilentlyContinue
            $patchManager | Should -Not -BeNullOrEmpty
        }
    }
}
Describe "Core Application Cross-Platform Tests" -Tag @('Maintenance', 'CoreApp', 'CrossPlatform') {
    
    Context "Platform Compatibility" {
        
        It "should work on current platform" {
            $env:PLATFORM | Should -BeIn @('Windows', 'Linux', 'macOS')
        }
        
        It "should handle platform-specific scripts appropriately" {
            $windowsScripts = $script:CoreScripts | Where-Object { $_.Name -match '^01\d+_' }
            
            foreach ($script in $windowsScripts) {
                $content = Get-Content $script.FullName -Raw
                if ($env:PLATFORM -ne 'Windows') {
                    # On non-Windows, these scripts should either skip or handle gracefully
                    $content | Should -Match '(IsWindows|Skip|platform)' -Because "$($script.Name) should handle non-Windows platforms"
                }
            }
        }
        
        It "should use cross-platform paths" {
            foreach ($script in $script:CoreScripts) {
                $content = Get-Content $script.FullName -Raw
                # Check for Windows-specific paths
                $content | Should -Not -Match '\\\\|C:\\' -Because "$($script.Name) should use cross-platform paths"
            }
        }
    }
}
Describe "Automated Test Generation and Validation" -Tag @('Critical', 'CoreApp', 'Automation') {
    
    Context "Continuous Test Coverage" {
        
        It "should have tests for all core scripts" {
            $coreScriptNames = $script:CoreScripts.BaseName
            $testFile = Get-Content $PSCommandPath -Raw
            
            foreach ($scriptName in $coreScriptNames) {
                if ($scriptName -match '^0\d+_') {
                    $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName"
                }
            }
        }
        
        It "should validate test completeness" {
            $testCounts = @{
                'Syntax' = 0
                'Function' = 0
                'Integration' = 0
                'Platform' = 0
            }
            
            $testFile = Get-Content $PSCommandPath -Raw
            $testCounts.Syntax = ($testFile | Select-String -Pattern 'syntax|parse' -AllMatches).Matches.Count
            $testCounts.Function = ($testFile | Select-String -Pattern 'function|define' -AllMatches).Matches.Count
            $testCounts.Integration = ($testFile | Select-String -Pattern 'integration|invoke' -AllMatches).Matches.Count
            $testCounts.Platform = ($testFile | Select-String -Pattern 'platform|cross' -AllMatches).Matches.Count
            
            $testCounts.Syntax | Should -BeGreaterThan 0
            $testCounts.Function | Should -BeGreaterThan 0
            $testCounts.Integration | Should -BeGreaterThan 0
            $testCounts.Platform | Should -BeGreaterThan 0
        }
        
        It "should enforce PatchManager usage for changes" {
            # Verify that any changes to CoreApp go through PatchManager
            $patchManagerCommands = @(
                'New-PatchOperation'
                'Invoke-PatchValidation' 
                'Submit-PatchForReview'
            )
            
            foreach ($cmd in $patchManagerCommands) {
                Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow"
            }
        }
    }
    
    Context "Test Result Analysis" {
        
        It "should generate comprehensive test reports" {
            $script:TestResults['CoreApp'] = @{
                TotalTests = (Get-ChildItem $PSCommandPath | Measure-Object).Count
                Timestamp = Get-Date
                Platform = $env:PLATFORM
                PowerShellVersion = $PSVersionTable.PSVersion
            }
            
            $script:TestResults.Count | Should -BeGreaterThan 0
        }
        
        It "should validate against test quality metrics" {
            # Ensure we have adequate test coverage
            $totalTests = 25  # Minimum expected tests
            $actualTests = (Select-String -Path $PSCommandPath -Pattern '\s+It\s+"' | Measure-Object).Count
            
            $actualTests | Should -BeGreaterOrEqual $totalTests -Because "Should have at least $totalTests tests for comprehensive coverage"
        }
    }
}
AfterAll {
    # Clean up test environment
    Write-CustomLog "CoreApp tests completed. Results: $($script:TestResults | ConvertTo-Json -Depth 2)" -Level INFO
    
    # Generate test coverage report if running in CI
    if ($env:CI -or $env:GITHUB_ACTIONS) {
        $coverageReport = @{
            TestFile = $PSCommandPath
            Results = $script:TestResults
            Timestamp = Get-Date
            Environment = @{
                Platform = $env:PLATFORM
                PowerShell = $PSVersionTable.PSVersion
                ProjectRoot = $env:PROJECT_ROOT
            }
        }
        
        $reportPath = "$env:PROJECT_ROOT/coverage/CoreApp-TestReport.json"
        $coverageReport | ConvertTo-Json -Depth 3 | Set-Content -Path $reportPath
        Write-CustomLog "Test coverage report saved to: $reportPath" -Level SUCCESS
    }
}
', because Should have test coverage for 0216_Set-LabProfile, but it did not match.</message>
                      <stack-trace>[0] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[3] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[4] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[5] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[6] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[7] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[8] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[9] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[10] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[11] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[12] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[13] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[14] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[15] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[16] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[17] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[18] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[19] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[20] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[21] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[22] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[23] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[24] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[25] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[26] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[27] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[28] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[29] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[30] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[31] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[32] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[33] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[34] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[35] at $testFile | Should -Match $scriptName -Because "Should have test coverage for $scriptName", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:265
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="should validate test completeness" name="Automated Test Generation and Validation.Continuous Test Coverage.should validate test completeness" time="0.0022" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should enforce PatchManager usage for changes" name="Automated Test Generation and Validation.Continuous Test Coverage.should enforce PatchManager usage for changes" time="0.0703" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected a value, because New-PatchOperation should be available for PatchManager workflow, but got $null or empty.
[1] Expected a value, because Invoke-PatchValidation should be available for PatchManager workflow, but got $null or empty.
[2] Expected a value, because Submit-PatchForReview should be available for PatchManager workflow, but got $null or empty.</message>
                      <stack-trace>[0] at Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:299
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:299
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:299
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:299
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[2] at Get-Command $cmd -ErrorAction SilentlyContinue | Should -Not -BeNullOrEmpty -Because "$cmd should be available for PatchManager workflow", C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:299
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8186
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\CoreApp.Tests.ps1:299
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Automated Test Generation and Validation.Test Result Analysis" executed="True" result="Success" success="True" time="0.3061" asserts="0" description="Automated Test Generation and Validation.Test Result Analysis">
                <results>
                  <test-case description="should generate comprehensive test reports" name="Automated Test Generation and Validation.Test Result Analysis.should generate comprehensive test reports" time="0.0013" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="should validate against test quality metrics" name="Automated Test Generation and Validation.Test Result Analysis.should validate against test quality metrics" time="0.0051" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Download-Archive.Tests.ps1" executed="True" result="Success" success="True" time="0.124" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Download-Archive.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Download-Archive Tests" executed="True" result="Success" success="True" time="0.0815" asserts="0" description="Download-Archive Tests">
            <results>
              <test-suite type="TestFixture" name="Download-Archive Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="Download-Archive Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Download-Archive Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Download-Archive Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0072" asserts="0" description="Download-Archive Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Download-Archive Tests.Functionality Tests.should execute without errors" time="0.0012" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\EscapePathArgument.Tests.ps1" executed="True" result="Success" success="True" time="0.1151" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\EscapePathArgument.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="EscapePathArgument Tests" executed="True" result="Success" success="True" time="0.0775" asserts="0" description="EscapePathArgument Tests">
            <results>
              <test-suite type="TestFixture" name="EscapePathArgument Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="EscapePathArgument Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="EscapePathArgument Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="EscapePathArgument Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0065" asserts="0" description="EscapePathArgument Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="EscapePathArgument Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Expand-All.Tests.ps1" executed="True" result="Success" success="True" time="0.1211" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Expand-All.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Expand-All Tests" executed="True" result="Success" success="True" time="0.0841" asserts="0" description="Expand-All Tests">
            <results>
              <test-suite type="TestFixture" name="Expand-All Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="Expand-All Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Expand-All Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Expand-All Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="Expand-All Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Expand-All Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Format-Config.Tests.ps1" executed="True" result="Success" success="True" time="0.116" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Format-Config.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Format-Config Tests" executed="True" result="Success" success="True" time="0.0801" asserts="0" description="Format-Config Tests">
            <results>
              <test-suite type="TestFixture" name="Format-Config Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="Format-Config Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Format-Config Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Format-Config Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0112" asserts="0" description="Format-Config Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Format-Config Tests.Functionality Tests.should execute without errors" time="0.0048" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Hypervisor.Tests.ps1" executed="True" result="Success" success="True" time="0.1181" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Hypervisor.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Hypervisor Tests" executed="True" result="Success" success="True" time="0.0808" asserts="0" description="Hypervisor Tests">
            <results>
              <test-suite type="TestFixture" name="Hypervisor Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="Hypervisor Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Hypervisor Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Hypervisor Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="Hypervisor Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Hypervisor Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Initialize-OpenTofu.Tests.ps1" executed="True" result="Success" success="True" time="0.1257" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Initialize-OpenTofu.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Initialize-OpenTofu Tests" executed="True" result="Success" success="True" time="0.0836" asserts="0" description="Initialize-OpenTofu Tests">
            <results>
              <test-suite type="TestFixture" name="Initialize-OpenTofu Tests.Module Loading" executed="True" result="Success" success="True" time="0.0043" asserts="0" description="Initialize-OpenTofu Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Initialize-OpenTofu Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Initialize-OpenTofu Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0078" asserts="0" description="Initialize-OpenTofu Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Initialize-OpenTofu Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Invoke-LabDownload.Tests.ps1" executed="True" result="Success" success="True" time="0.1175" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Invoke-LabDownload.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Invoke-LabDownload Tests" executed="True" result="Success" success="True" time="0.0816" asserts="0" description="Invoke-LabDownload Tests">
            <results>
              <test-suite type="TestFixture" name="Invoke-LabDownload Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="Invoke-LabDownload Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Invoke-LabDownload Tests.Module Loading.should load required modules" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Invoke-LabDownload Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0068" asserts="0" description="Invoke-LabDownload Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Invoke-LabDownload Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\InvokeOpenTofuInstaller.Tests.ps1" executed="True" result="Success" success="True" time="0.1135" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\InvokeOpenTofuInstaller.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="InvokeOpenTofuInstaller Tests" executed="True" result="Success" success="True" time="0.0779" asserts="0" description="InvokeOpenTofuInstaller Tests">
            <results>
              <test-suite type="TestFixture" name="InvokeOpenTofuInstaller Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="InvokeOpenTofuInstaller Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="InvokeOpenTofuInstaller Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="InvokeOpenTofuInstaller Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0066" asserts="0" description="InvokeOpenTofuInstaller Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="InvokeOpenTofuInstaller Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\kicker-bootstrap.Tests.ps1" executed="True" result="Success" success="True" time="0.1112" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\kicker-bootstrap.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="kicker-bootstrap Tests" executed="True" result="Success" success="True" time="0.0753" asserts="0" description="kicker-bootstrap Tests">
            <results>
              <test-suite type="TestFixture" name="kicker-bootstrap Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="kicker-bootstrap Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="kicker-bootstrap Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="kicker-bootstrap Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0063" asserts="0" description="kicker-bootstrap Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="kicker-bootstrap Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Kickstart-Bootstrap.Tests.ps1" executed="True" result="Success" success="True" time="0.1227" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Kickstart-Bootstrap.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Kickstart-Bootstrap Tests" executed="True" result="Success" success="True" time="0.0811" asserts="0" description="Kickstart-Bootstrap Tests">
            <results>
              <test-suite type="TestFixture" name="Kickstart-Bootstrap Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="Kickstart-Bootstrap Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Kickstart-Bootstrap Tests.Module Loading.should load required modules" time="0.0011" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Kickstart-Bootstrap Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.007" asserts="0" description="Kickstart-Bootstrap Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Kickstart-Bootstrap Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Logger.Tests.ps1" executed="True" result="Success" success="True" time="0.1216" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Logger.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Logger Tests" executed="True" result="Success" success="True" time="0.0854" asserts="0" description="Logger Tests">
            <results>
              <test-suite type="TestFixture" name="Logger Tests.Module Loading" executed="True" result="Success" success="True" time="0.0042" asserts="0" description="Logger Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Logger Tests.Module Loading.should load required modules" time="0.0012" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Logger Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0073" asserts="0" description="Logger Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Logger Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Menu.Tests.ps1" executed="True" result="Success" success="True" time="0.1143" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Menu.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Menu Tests" executed="True" result="Success" success="True" time="0.0757" asserts="0" description="Menu Tests">
            <results>
              <test-suite type="TestFixture" name="Menu Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="Menu Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Menu Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Menu Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0064" asserts="0" description="Menu Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Menu Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Network.Tests.ps1" executed="True" result="Success" success="True" time="0.1083" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Network.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Network Tests" executed="True" result="Success" success="True" time="0.0735" asserts="0" description="Network Tests">
            <results>
              <test-suite type="TestFixture" name="Network Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="Network Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Network Tests.Module Loading.should load required modules" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Network Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0065" asserts="0" description="Network Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Network Tests.Functionality Tests.should execute without errors" time="0.0007" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\NodeScripts.Tests.ps1" executed="True" result="Success" success="True" time="0.1199" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\NodeScripts.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="NodeScripts Tests" executed="True" result="Success" success="True" time="0.0827" asserts="0" description="NodeScripts Tests">
            <results>
              <test-suite type="TestFixture" name="NodeScripts Tests.Module Loading" executed="True" result="Success" success="True" time="0.0039" asserts="0" description="NodeScripts Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="NodeScripts Tests.Module Loading.should load required modules" time="0.0012" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="NodeScripts Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0071" asserts="0" description="NodeScripts Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="NodeScripts Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\OpenTofuInstaller.Tests.ps1" executed="True" result="Success" success="True" time="0.1225" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\OpenTofuInstaller.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="OpenTofuInstaller Tests" executed="True" result="Success" success="True" time="0.0847" asserts="0" description="OpenTofuInstaller Tests">
            <results>
              <test-suite type="TestFixture" name="OpenTofuInstaller Tests.Module Loading" executed="True" result="Success" success="True" time="0.007" asserts="0" description="OpenTofuInstaller Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="OpenTofuInstaller Tests.Module Loading.should load required modules" time="0.0043" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="OpenTofuInstaller Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0106" asserts="0" description="OpenTofuInstaller Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="OpenTofuInstaller Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\PrepareHyperVProvider.Tests.ps1" executed="True" result="Success" success="True" time="0.12" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\PrepareHyperVProvider.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="PrepareHyperVProvider Tests" executed="True" result="Success" success="True" time="0.0803" asserts="0" description="PrepareHyperVProvider Tests">
            <results>
              <test-suite type="TestFixture" name="PrepareHyperVProvider Tests.Module Loading" executed="True" result="Success" success="True" time="0.0037" asserts="0" description="PrepareHyperVProvider Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="PrepareHyperVProvider Tests.Module Loading.should load required modules" time="0.0012" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="PrepareHyperVProvider Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0069" asserts="0" description="PrepareHyperVProvider Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="PrepareHyperVProvider Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Resolve-ProjectPath.Tests.ps1" executed="True" result="Success" success="True" time="0.1157" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\Resolve-ProjectPath.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Resolve-ProjectPath Tests" executed="True" result="Success" success="True" time="0.0802" asserts="0" description="Resolve-ProjectPath Tests">
            <results>
              <test-suite type="TestFixture" name="Resolve-ProjectPath Tests.Module Loading" executed="True" result="Success" success="True" time="0.0036" asserts="0" description="Resolve-ProjectPath Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="Resolve-ProjectPath Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Resolve-ProjectPath Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="Resolve-ProjectPath Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="Resolve-ProjectPath Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\runner.Tests.ps1" executed="True" result="Success" success="True" time="0.12" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\runner.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="runner Tests" executed="True" result="Success" success="True" time="0.0798" asserts="0" description="runner Tests">
            <results>
              <test-suite type="TestFixture" name="runner Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="runner Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="runner Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="runner Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0072" asserts="0" description="runner Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="runner Tests.Functionality Tests.should execute without errors" time="0.0008" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\RunnerScripts.Tests.ps1" executed="True" result="Success" success="True" time="0.1212" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\RunnerScripts.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="RunnerScripts Tests" executed="True" result="Success" success="True" time="0.0843" asserts="0" description="RunnerScripts Tests">
            <results>
              <test-suite type="TestFixture" name="RunnerScripts Tests.Module Loading" executed="True" result="Success" success="True" time="0.0034" asserts="0" description="RunnerScripts Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="RunnerScripts Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="RunnerScripts Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.01" asserts="0" description="RunnerScripts Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="RunnerScripts Tests.Functionality Tests.should execute without errors" time="0.001" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\ScriptTemplate.Tests.ps1" executed="True" result="Success" success="True" time="0.1182" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\integration\ScriptTemplate.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="ScriptTemplate Tests" executed="True" result="Success" success="True" time="0.0789" asserts="0" description="ScriptTemplate Tests">
            <results>
              <test-suite type="TestFixture" name="ScriptTemplate Tests.Module Loading" executed="True" result="Success" success="True" time="0.0035" asserts="0" description="ScriptTemplate Tests.Module Loading">
                <results>
                  <test-case description="should load required modules" name="ScriptTemplate Tests.Module Loading.should load required modules" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="ScriptTemplate Tests.Functionality Tests" executed="True" result="Success" success="True" time="0.0067" asserts="0" description="ScriptTemplate Tests.Functionality Tests">
                <results>
                  <test-case description="should execute without errors" name="ScriptTemplate Tests.Functionality Tests.should execute without errors" time="0.0009" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1" executed="True" result="Failure" success="False" time="0.123" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Code Quality and Linting Tests" executed="True" result="Failure" success="False" time="0.082" asserts="0" description="Code Quality and Linting Tests">
            <results>
              <test-suite type="TestFixture" name="Code Quality and Linting Tests.PSScriptAnalyzer Validation" executed="True" result="Failure" success="False" time="0.0131" asserts="0" description="Code Quality and Linting Tests.PSScriptAnalyzer Validation">
                <results>
                  <test-case description="Should have PSScriptAnalyzer settings file" name="Code Quality and Linting Tests.PSScriptAnalyzer Validation.Should have PSScriptAnalyzer settings file" time="0.004" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path $PSAnalyzerSettings | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:16
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:16
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should pass PSScriptAnalyzer analysis for PowerShell modules" name="Code Quality and Linting Tests.PSScriptAnalyzer Validation.Should pass PSScriptAnalyzer analysis for PowerShell modules" time="0.0028" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should pass PSScriptAnalyzer analysis for PowerShell scripts" name="Code Quality and Linting Tests.PSScriptAnalyzer Validation.Should pass PSScriptAnalyzer analysis for PowerShell scripts" time="0.0036" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Code Quality and Linting Tests.Python Code Quality" executed="True" result="Failure" success="False" time="0.0306" asserts="0" description="Code Quality and Linting Tests.Python Code Quality">
                <results>
                  <test-case description="Should have Python linting configuration files" name="Code Quality and Linting Tests.Python Code Quality.Should have Python linting configuration files" time="0.0069" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected $true, but got $false.
[1] Expected $true, but got $false.</message>
                      <stack-trace>[0] at Test-Path './.flake8' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:54
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:54
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at Test-Path './pyproject.toml' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:55
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:55
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should pass flake8 analysis for Python source code" name="Code Quality and Linting Tests.Python Code Quality.Should pass flake8 analysis for Python source code" time="0.006" asserts="0" success="False" result="Inconclusive" executed="True" />
                  <test-case description="Should pass flake8 analysis for Python test code" name="Code Quality and Linting Tests.Python Code Quality.Should pass flake8 analysis for Python test code" time="0.0014" asserts="0" success="False" result="Inconclusive" executed="True" />
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Code Quality and Linting Tests.Cross-Platform Compatibility" executed="True" result="Failure" success="False" time="0.0422" asserts="0" description="Code Quality and Linting Tests.Cross-Platform Compatibility">
                <results>
                  <test-case description="Should use proper path separators in PowerShell scripts" name="Code Quality and Linting Tests.Cross-Platform Compatibility.Should use proper path separators in PowerShell scripts" time="0.0029" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should use proper line endings" name="Code Quality and Linting Tests.Cross-Platform Compatibility.Should use proper line endings" time="0.006" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>RuntimeException: Cannot index into a null array.</message>
                      <stack-trace>at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:112
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Code Quality and Linting Tests.Parallel Execution Integration" executed="True" result="Failure" success="False" time="0.0747" asserts="0" description="Code Quality and Linting Tests.Parallel Execution Integration">
                <results>
                  <test-case description="Should be able to create lint tasks" name="Code Quality and Linting Tests.Parallel Execution Integration.Should be able to create lint tasks" time="0.0089" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should be able to execute parallel linting (dry run)" name="Code Quality and Linting Tests.Parallel Execution Integration.Should be able to execute parallel linting (dry run)" time="0.0207" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected no exception to be thrown, but an exception "The term 'Invoke-ParallelTaskExecution' is not recognized as a name of a cmdlet, function, script file, or executable program.
Check the spelling of the name, or if a path was included, verify that the path is correct and try again." was thrown from C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:149 char:15
    +             { Invoke-ParallelTaskExecution -Tasks $testLintTasks -Tas …
    +               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~.</message>
                      <stack-trace>at { Invoke-ParallelTaskExecution -Tasks $testLintTasks -TaskType 'Lint' -MaxConcurrency 1 } | Should -Not -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:149
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\LintingTests.Tests.ps1:149
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
      <test-suite type="TestFixture" name="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1" executed="True" result="Failure" success="False" time="0.1355" asserts="0" description="C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1">
        <results>
          <test-suite type="TestFixture" name="Project Structure and Integration Tests" executed="True" result="Failure" success="False" time="0.0925" asserts="0" description="Project Structure and Integration Tests">
            <results>
              <test-suite type="TestFixture" name="Project Structure and Integration Tests.Project Directory Structure" executed="True" result="Failure" success="False" time="0.0311" asserts="0" description="Project Structure and Integration Tests.Project Directory Structure">
                <results>
                  <test-case description="Should have all required top-level directories" name="Project Structure and Integration Tests.Project Directory Structure.Should have all required top-level directories" time="0.0068" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path $_ | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:7
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:7
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:6
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have PowerShell source structure" name="Project Structure and Integration Tests.Project Directory Structure.Should have PowerShell source structure" time="0.0049" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path 'src/pwsh' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:12
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:12
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have Python source structure" name="Project Structure and Integration Tests.Project Directory Structure.Should have Python source structure" time="0.0072" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected $true, but got $false.
[1] Expected $true, but got $false.</message>
                      <stack-trace>[0] at Test-Path 'src/python' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:17
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:17
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at Test-Path 'src/python/labctl' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:18
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:18
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have test structure" name="Project Structure and Integration Tests.Project Directory Structure.Should have test structure" time="0.0092" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path 'tests/pytest' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:23
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:23
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Project Structure and Integration Tests.Configuration Files" executed="True" result="Failure" success="False" time="0.05" asserts="0" description="Project Structure and Integration Tests.Configuration Files">
                <results>
                  <test-case description="Should have project configuration files" name="Project Structure and Integration Tests.Configuration Files.Should have project configuration files" time="0.0042" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path 'configs/PROJECT-MANIFEST.json' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:29
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:29
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have Python configuration" name="Project Structure and Integration Tests.Configuration Files.Should have Python configuration" time="0.004" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path 'src/python/pyproject.toml' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:33
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:33
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have test configurations" name="Project Structure and Integration Tests.Configuration Files.Should have test configurations" time="0.0076" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>[0] Expected $true, but got $false.
[1] Expected $true, but got $false.</message>
                      <stack-trace>[0] at Test-Path 'tests/PesterConfiguration.psd1' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:37
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:37
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1
[1] at Test-Path 'tests/PSScriptAnalyzerSettings.psd1' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:38
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:38
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Project Structure and Integration Tests.Master Test Runner" executed="True" result="Failure" success="False" time="0.0659" asserts="0" description="Project Structure and Integration Tests.Master Test Runner">
                <results>
                  <test-case description="Should have master test runner script" name="Project Structure and Integration Tests.Master Test Runner.Should have master test runner script" time="0.004" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path 'Run-AllTests.ps1' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:44
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:44
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have test documentation" name="Project Structure and Integration Tests.Master Test Runner.Should have test documentation" time="0.0041" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at Test-Path 'TEST-CONFIGURATION.md' | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:48
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:48
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should be able to execute test runner script" name="Project Structure and Integration Tests.Master Test Runner.Should be able to execute test runner script" time="0.0048" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected no exception to be thrown, but an exception "Cannot find path 'C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\Run-AllTests.ps1' because it does not exist." was thrown from C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:52 char:15
    + …            { Get-Content 'Run-AllTests.ps1' -ErrorAction Stop } | Sho …
    +                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.</message>
                      <stack-trace>at { Get-Content 'Run-AllTests.ps1' -ErrorAction Stop } | Should -Not -Throw, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:52
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8193
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:52
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                </results>
              </test-suite>
              <test-suite type="TestFixture" name="Project Structure and Integration Tests.Integration Validation" executed="True" result="Failure" success="False" time="0.0899" asserts="0" description="Project Structure and Integration Tests.Integration Validation">
                <results>
                  <test-case description="Should have consistent module naming or valid variations" name="Project Structure and Integration Tests.Integration Validation.Should have consistent module naming or valid variations" time="0.0101" asserts="0" success="False" result="Failure" executed="True">
                    <failure>
                      <message>Expected $true, but got $false.</message>
                      <stack-trace>at ($moduleName -eq $moduleDir -or $moduleName -like "$moduleDir-*") | Should -Be $true, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:62
at Invoke-Assertion, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8257
at Should&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:8189
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:62
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\0. wizzense\opentofu-lab-automation\tests\pester\ProjectStructure.Tests.ps1:58
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2157
at Invoke-TestItem, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1199
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:835
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:893
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2024
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1985
at Invoke-ScriptBlock, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2160
at Invoke-Block, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:940
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1688
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.ps1:3
at &lt;ScriptBlock&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3260
at Invoke-InNewScriptScope, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:3267
at Run-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:1691
at Invoke-Test, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:2512
at Invoke-Pester&lt;End&gt;, C:\Users\alexa\OneDrive\Documents\PowerShell\Modules\Pester\5.7.1\Pester.psm1:4960
at &lt;ScriptBlock&gt;, &lt;No file&gt;:1</stack-trace>
                    </failure>
                  </test-case>
                  <test-case description="Should have Python modules with __init__.py files" name="Project Structure and Integration Tests.Integration Validation.Should have Python modules with __init__.py files" time="0.0083" asserts="0" success="True" result="Success" executed="True" />
                  <test-case description="Should have no obvious syntax errors in PowerShell files" name="Project Structure and Integration Tests.Integration Validation.Should have no obvious syntax errors in PowerShell files" time="0.0031" asserts="0" success="True" result="Success" executed="True" />
                </results>
              </test-suite>
            </results>
          </test-suite>
        </results>
      </test-suite>
    </results>
  </test-suite>
</test-results>