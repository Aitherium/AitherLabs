#Requires -Version 7.0
<#
.SYNOPSIS
    Pe    begin {
        # Initialize cleanup results tracking
        $script:CleanupResults = @{
            Success = $true
            StartTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            TotalSizeReclaimed = 0
            FilesRemoved = 0
            DirectoriesRemoved = 0
            Errors = @()
            DryRun = $DryRun.IsPresent
            TargetsCleaned = @()
        }
    }p functionality integrated into PatchManager
    
.DESCRIPTION
    Migrated from BackupManager to provide comprehensive permanent cleanup
    with Git integration and change control features.
    
.PARAMETER CleanupTargets
    Array of cleanup targets: 'OldBackups', 'TempFiles', 'LogFiles', 'DuplicateFiles', 'EmptyDirectories'
    
.PARAMETER AgeThresholdDays
    Delete files older than this many days (default: 30)
    
.PARAMETER DryRun
    Show what would be deleted without actually deleting
    
.PARAMETER Force
    Skip confirmations and perform cleanup
    
.EXAMPLE
    Invoke-PermanentCleanup -CleanupTargets @('OldBackups', 'TempFiles') -AgeThresholdDays 7 -DryRun
    
.EXAMPLE
    Invoke-PermanentCleanup -CleanupTargets @('LogFiles') -Force
    
.NOTES
    Part of PatchManager's comprehensive cleanup system.
    Provides audit trails and Git integration.
#>

function Invoke-PermanentCleanup {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$CleanupTargets,
        
        [Parameter()]
        [switch]$DryRun,
        
        [Parameter()]
        [switch]$Force
    )
    
    begin {
        # Initialize cleanup results tracking
        $script:CleanupResults = @{
            StartTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"        # Results object for tracking cleanup operations
        $script:CleanupResults = @{
            Success = $true
            TotalSizeReclaimed = 0
            FilesRemoved = 0
            DirectoriesRemoved = 0
            Errors = @()
            DryRun = $DryRun.IsPresent
            TargetsCleaned = @()
        }
    
    process {
        try {
            # Parse the cleanup targets
            $targets = $CleanupTargets | ConvertFrom-Json
            foreach ($target in $targets) {
                if (-not $target.Path -or -not $target.MaxAge) {
                    Write-CustomLog "Invalid target configuration: Missing Path or MaxAge" "ERROR"
                    continue
                }
                
                $cutoffDate = (Get-Date).AddDays(-$target.MaxAge)
                Write-CustomLog "Processing cleanup target: $($target.Path) with cutoff date: $cutoffDate"
                
                # Perform the cleanup
                $result = Remove-OldFiles -Path $target.Path -CutoffDate $cutoffDate -DryRun:$DryRun -Force:$Force
                
                if ($result) {
                    $script:CleanupResults.TotalSizeReclaimed += $result.SizeReclaimed
                    $script:CleanupResults.FilesRemoved += $result.FilesRemoved
                    $script:CleanupResults.DirectoriesRemoved += $result.DirectoriesRemoved
                    $script:CleanupResults.TargetsCleaned += @{
                        Path = $target.Path
                        FilesRemoved = $result.FilesRemoved
                        SizeReclaimed = $result.SizeReclaimed
                    }
                }
            }
              # Update the cleanup manifest
            $manifestPath = Join-Path $PWD "cleanup-manifest.json"
            Write-CustomLog "Cleanup operation completed. Total size reclaimed: $($script:CleanupResults.TotalSizeReclaimed) bytes"
        }
        catch {
            Write-CustomLog "Error during cleanup operation: $_" "ERROR"
            throw
        }
    }
    
    end {
        return $script:CleanupResults
    }
}


